<!DOCTYPE HTML>
<html lang="en">

<head>


<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta property="og:image" content="https://www.dash.org/assets/img/graphics/dash_circle_normal.png" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Developer Guide - Bitcoin</title>

<link rel="stylesheet" href="/css/font-awesome-4.4.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/main.css">
<!--[if lt IE 8]><link rel="stylesheet" href="/css/ie.css"><script type="text/javascript" src="/js/ie.js"></script><![endif]-->
<!--[if IE 8]><link rel="stylesheet" href="/css/ie8.css"><![endif]-->


<script type="text/javascript" src="/js/base.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

  <script src="/js/jquery/jquery-1.11.2.min.js"></script>
  <script src="/js/jquery/jquery.qrcode.min.js"></script>

<link rel="shortcut icon" href="/favicon.png">
<link rel="apple-touch-icon-precomposed" href="/img/icons/logo_ios.png"/>
<script>
    window.cookieconsent_options = {
        theme: 'light-floating'
    }
</script>
<script type="text/javascript" src="/js/cookieconsent/cookieconsent.js"></script>
<script>
if( navigator.doNotTrack != "yes" && navigator.doNotTrack != "1" && window.doNotTrack != "1" && navigator.msDoNotTrack != "1" ){
	var script = document.createElement('script');
	script.src = '/js/analytics.js'
	document.getElementsByTagName("head")[0].appendChild(script);
}
</script>

</head>

<body>

  






<div id="detectmobile" class="detectmobile"></div>







<div class="head"><div>
  
<ul class="lang">
  <li><a>English</a>
  <ul>
    <li><ul>
      
      
        
          <li><a href="/id/">Bahasa Indonesia</a></li>
        
        
          <li><a href="/da/">Dansk</a></li>
        
        
          <li><a href="/de/">Deutsch</a></li>
        
        
          <li><a href="/en/" class="active">English</a></li>
        
        
          <li><a href="/es/">Español</a></li>
        
        
          <li><a href="/fr/">Français</a></li>
        
        
          <li><a href="/it/">Italiano</a></li>
        
        
          <li><a href="/hu/">Magyar</a></li>
        
        
          <li><a href="/nl/">Nederlands</a></li>
        
        
          <li><a href="/pl/">Polski</a></li>
        
        
          <li><a href="/pt_BR/">Português Brasil</a></li>
        
        
          <li><a href="/ro/">Română</a></li>
        
        
          <li><a href="/sl/">Slovenščina</a></li>
        
        
          <li><a href="/sv/">Svenska</a></li>
        
        </ul></li><li><ul>
          <li><a href="/tr/">Türkçe</a></li>
        
        
          <li><a href="/el/">Ελληνικά</a></li>
        
        
          <li><a href="/bg/">български</a></li>
        
        
          <li><a href="/ru/">Русский</a></li>
        
        
          <li><a href="/uk/">Українська</a></li>
        
        
          <li><a href="/ar/">العربية</a></li>
        
        
          <li><a href="/fa/">فارسی</a></li>
        
        
          <li><a href="/hi/">हिन्दी</a></li>
        
        
          <li><a href="/ko/">한국의</a></li>
        
        
          <li><a href="/ja/">日本語</a></li>
        
        
          <li><a href="/zh_CN/">简体中文</a></li>
        
        
          <li><a href="/zh_TW/">繁體中文</a></li>
        
      </ul></li>
    </ul>
  </li>
</ul>

  

<a id="menumobile" class="menumobile" onclick="mobileMenuShow(event);" ontouchstart="mobileMenuShow(event);"></a>

  

<a class="logo" href="/en/"><img src="/img/icons/logotop.svg" alt="Dash"></a>

  
<div id="langselect" class="langselect"><select onchange="window.location=this.value;">
    
          <option value="/id/">Bahasa Indonesia</option>
    
          <option value="/da/">Dansk</option>
    
          <option value="/de/">Deutsch</option>
    
          <option value="/en/" selected="selected">English</option>
    
          <option value="/es/">Español</option>
    
          <option value="/fr/">Français</option>
    
          <option value="/it/">Italiano</option>
    
          <option value="/hu/">Magyar</option>
    
          <option value="/nl/">Nederlands</option>
    
          <option value="/pl/">Polski</option>
    
          <option value="/pt_BR/">Português Brasil</option>
    
          <option value="/ro/">Română</option>
    
          <option value="/sl/">Slovenščina</option>
    
          <option value="/sv/">Svenska</option>
    
          <option value="/tr/">Türkçe</option>
    
          <option value="/el/">Ελληνικά</option>
    
          <option value="/bg/">български</option>
    
          <option value="/ru/">Русский</option>
    
          <option value="/uk/">Українська</option>
    
          <option value="/ar/">العربية</option>
    
          <option value="/fa/">فارسی</option>
    
          <option value="/hi/">हिन्दी</option>
    
          <option value="/ko/">한국의</option>
    
          <option value="/ja/">日本語</option>
    
          <option value="/zh_CN/">简体中文</option>
    
          <option value="/zh_TW/">繁體中文</option>
    
</select></div>

  

<ul id="menusimple" class="menusimple menumain" onclick="mobileMenuHover(event);" ontouchstart="mobileMenuHover(event);">
  <li><a>Introduction</a>
    <ul>
      <li><a href="/en/bitcoin-for-individuals">Individuals</a></li>
      <li><a href="/en/bitcoin-for-businesses">Businesses</a></li>
      <li><a href="/en/bitcoin-for-developers">Developers</a></li>
      <li><a href="/en/getting-started">Getting started</a></li>
      <li><a href="/en/how-it-works">How it works</a></li>
      <li><a href="/en/you-need-to-know">You need to know</a></li>
    </ul>
  </li>
  <li><a>Resources</a>
    <ul>
      <li><a href="/en/resources">Resources</a>
      <li><a href="/en/exchanges">Exchanges</a></li>
      <li><a href="/en/community">Community</a></li>
      <li><a href="/en/developer-documentation">Documentation</a></li>
      <li><a href="/en/vocabulary">Vocabulary</a></li>
      <li><a href="/en/events">Events</a></li>
      
        <li><a href="/en/bitcoin-core/">Bitcoin Core</a></li>
      
    </ul>
  </li>
  <li><a href="/en/innovation">Innovation</a></li>
  <li><a>Participate</a>
    <ul>
      <li><a href="/en/support-bitcoin">Support Bitcoin</a>
      <li><a href="/en/buy">Buy Bitcoin</a></li>
      <li><a href="/en/full-node">Running a full node</a></li>
      <li><a href="/en/development">Development</a></li>
    </ul>
  </li>
  <li><a href="/en/faq">FAQ</a></li>
</ul>

</div></div>

<div class="body">
  

<div class="breadcrumbs">
  
    
      <a href="/en/developer-documentation">Dev Docs</a>
        
      &gt;
    
  
    
      Guide
      
    
  
</div>

  

<div id="content" class="content">
  <link rel="stylesheet" href="/css/jquery-ui.min.css" />

<h1 id="bitcoin-developer-guide">Bitcoin Developer Guide</h1>

<p class="summary">Find detailed information about the Bitcoin protocol and related specifications.</p>

<div id="toc" class="toc">
  <div>

<ul id="markdown-toc">
  <li><a href="#block-chain" id="markdown-toc-block-chain">Block Chain</a>    <ul>
      <li><a href="#block-chain-overview" id="markdown-toc-block-chain-overview">Block Chain Overview</a></li>
      <li><a href="#proof-of-work" id="markdown-toc-proof-of-work">Proof Of Work</a></li>
      <li><a href="#block-height-and-forking" id="markdown-toc-block-height-and-forking">Block Height And Forking</a></li>
      <li><a href="#transaction-data" id="markdown-toc-transaction-data">Transaction Data</a></li>
      <li><a href="#consensus-rule-changes" id="markdown-toc-consensus-rule-changes">Consensus Rule Changes</a>        <ul>
          <li><a href="#detecting-forks" id="markdown-toc-detecting-forks">Detecting Forks</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#transactions" id="markdown-toc-transactions">Transactions</a>    <ul>
      <li><a href="#p2pkh-script-validation" id="markdown-toc-p2pkh-script-validation">P2PKH Script Validation</a></li>
      <li><a href="#p2sh-scripts" id="markdown-toc-p2sh-scripts">P2SH Scripts</a></li>
      <li><a href="#standard-transactions" id="markdown-toc-standard-transactions">Standard Transactions</a>        <ul>
          <li><a href="#non-standard-transactions" id="markdown-toc-non-standard-transactions">Non-Standard Transactions</a></li>
        </ul>
      </li>
      <li><a href="#signature-hash-types" id="markdown-toc-signature-hash-types">Signature Hash Types</a></li>
      <li><a href="#locktime-and-sequence-number" id="markdown-toc-locktime-and-sequence-number">Locktime And Sequence Number</a></li>
      <li><a href="#transaction-fees-and-change" id="markdown-toc-transaction-fees-and-change">Transaction Fees And Change</a></li>
      <li><a href="#avoiding-key-reuse" id="markdown-toc-avoiding-key-reuse">Avoiding Key Reuse</a></li>
      <li><a href="#transaction-malleability" id="markdown-toc-transaction-malleability">Transaction Malleability</a></li>
    </ul>
  </li>
  <li><a href="#contracts" id="markdown-toc-contracts">Contracts</a>    <ul>
      <li><a href="#escrow-and-arbitration" id="markdown-toc-escrow-and-arbitration">Escrow And Arbitration</a></li>
      <li><a href="#micropayment-channel" id="markdown-toc-micropayment-channel">Micropayment Channel</a></li>
      <li><a href="#coinjoin" id="markdown-toc-coinjoin">CoinJoin</a></li>
    </ul>
  </li>
  <li><a href="#wallets" id="markdown-toc-wallets">Wallets</a>    <ul>
      <li><a href="#wallet-programs" id="markdown-toc-wallet-programs">Wallet Programs</a>        <ul>
          <li><a href="#full-service-wallets" id="markdown-toc-full-service-wallets">Full-Service Wallets</a></li>
          <li><a href="#signing-only-wallets" id="markdown-toc-signing-only-wallets">Signing-Only Wallets</a>            <ul>
              <li><a href="#offline-wallets" id="markdown-toc-offline-wallets">Offline Wallets</a></li>
              <li><a href="#hardware-wallets" id="markdown-toc-hardware-wallets">Hardware Wallets</a></li>
            </ul>
          </li>
          <li><a href="#distributing-only-wallets" id="markdown-toc-distributing-only-wallets">Distributing-Only Wallets</a></li>
        </ul>
      </li>
      <li><a href="#wallet-files" id="markdown-toc-wallet-files">Wallet Files</a>        <ul>
          <li><a href="#private-key-formats" id="markdown-toc-private-key-formats">Private Key Formats</a>            <ul>
              <li><a href="#wallet-import-format-wif" id="markdown-toc-wallet-import-format-wif">Wallet Import Format (WIF)</a></li>
              <li><a href="#mini-private-key-format" id="markdown-toc-mini-private-key-format">Mini Private Key Format</a></li>
            </ul>
          </li>
          <li><a href="#public-key-formats" id="markdown-toc-public-key-formats">Public Key Formats</a></li>
          <li><a href="#hierarchical-deterministic-key-creation" id="markdown-toc-hierarchical-deterministic-key-creation">Hierarchical Deterministic Key Creation</a>            <ul>
              <li><a href="#hardened-keys" id="markdown-toc-hardened-keys">Hardened Keys</a></li>
              <li><a href="#storing-root-seeds" id="markdown-toc-storing-root-seeds">Storing Root Seeds</a></li>
            </ul>
          </li>
          <li><a href="#loose-key-wallets" id="markdown-toc-loose-key-wallets">Loose-Key Wallets</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#payment-processing" id="markdown-toc-payment-processing">Payment Processing</a>    <ul>
      <li><a href="#pricing-orders" id="markdown-toc-pricing-orders">Pricing Orders</a></li>
      <li><a href="#requesting-payments" id="markdown-toc-requesting-payments">Requesting Payments</a>        <ul>
          <li><a href="#plain-text" id="markdown-toc-plain-text">Plain Text</a></li>
          <li><a href="#bitcoin-uri" id="markdown-toc-bitcoin-uri">bitcoin: URI</a></li>
          <li><a href="#qr-codes" id="markdown-toc-qr-codes">QR Codes</a></li>
          <li><a href="#payment-protocol" id="markdown-toc-payment-protocol">Payment Protocol</a></li>
        </ul>
      </li>
      <li><a href="#verifying-payment" id="markdown-toc-verifying-payment">Verifying Payment</a></li>
      <li><a href="#issuing-refunds" id="markdown-toc-issuing-refunds">Issuing Refunds</a></li>
      <li><a href="#disbursing-income-limiting-forex-risk" id="markdown-toc-disbursing-income-limiting-forex-risk">Disbursing Income (Limiting Forex Risk)</a>        <ul>
          <li><a href="#merge-avoidance" id="markdown-toc-merge-avoidance">Merge Avoidance</a></li>
          <li><a href="#last-in-first-out-lifo" id="markdown-toc-last-in-first-out-lifo">Last In, First Out (LIFO)</a></li>
          <li><a href="#first-in-first-out-fifo" id="markdown-toc-first-in-first-out-fifo">First In, First Out (FIFO)</a></li>
        </ul>
      </li>
      <li><a href="#rebilling-recurring-payments" id="markdown-toc-rebilling-recurring-payments">Rebilling Recurring Payments</a></li>
    </ul>
  </li>
  <li><a href="#operating-modes" id="markdown-toc-operating-modes">Operating Modes</a>    <ul>
      <li><a href="#full-node" id="markdown-toc-full-node">Full Node</a></li>
      <li><a href="#simplified-payment-verification-spv" id="markdown-toc-simplified-payment-verification-spv">Simplified Payment Verification (SPV)</a>        <ul>
          <li><a href="#potential-spv-weaknesses" id="markdown-toc-potential-spv-weaknesses">Potential SPV Weaknesses</a></li>
          <li><a href="#bloom-filters" id="markdown-toc-bloom-filters">Bloom Filters</a></li>
          <li><a href="#application-of-bloom-filters" id="markdown-toc-application-of-bloom-filters">Application Of Bloom Filters</a></li>
        </ul>
      </li>
      <li><a href="#future-proposals" id="markdown-toc-future-proposals">Future Proposals</a></li>
    </ul>
  </li>
  <li><a href="#p2p-network" id="markdown-toc-p2p-network">P2P Network</a>    <ul>
      <li><a href="#peer-discovery" id="markdown-toc-peer-discovery">Peer Discovery</a></li>
      <li><a href="#connecting-to-peers" id="markdown-toc-connecting-to-peers">Connecting To Peers</a></li>
      <li><a href="#initial-block-download" id="markdown-toc-initial-block-download">Initial Block Download</a>        <ul>
          <li><a href="#blocks-first" id="markdown-toc-blocks-first">Blocks-First</a></li>
          <li><a href="#headers-first" id="markdown-toc-headers-first">Headers-First</a></li>
        </ul>
      </li>
      <li><a href="#block-broadcasting" id="markdown-toc-block-broadcasting">Block Broadcasting</a>        <ul>
          <li><a href="#orphan-blocks" id="markdown-toc-orphan-blocks">Orphan Blocks</a></li>
        </ul>
      </li>
      <li><a href="#transaction-broadcasting" id="markdown-toc-transaction-broadcasting">Transaction Broadcasting</a>        <ul>
          <li><a href="#memory-pool" id="markdown-toc-memory-pool">Memory Pool</a></li>
        </ul>
      </li>
      <li><a href="#misbehaving-nodes" id="markdown-toc-misbehaving-nodes">Misbehaving Nodes</a></li>
      <li><a href="#alerts" id="markdown-toc-alerts">Alerts</a></li>
    </ul>
  </li>
  <li><a href="#mining" id="markdown-toc-mining">Mining</a>    <ul>
      <li><a href="#solo-mining" id="markdown-toc-solo-mining">Solo Mining</a></li>
      <li><a href="#pool-mining" id="markdown-toc-pool-mining">Pool Mining</a></li>
      <li><a href="#block-prototypes" id="markdown-toc-block-prototypes">Block Prototypes</a>        <ul>
          <li><a href="#getwork-rpc" id="markdown-toc-getwork-rpc">getwork RPC</a></li>
          <li><a href="#getblocktemplate-rpc" id="markdown-toc-getblocktemplate-rpc">getblocktemplate RPC</a></li>
          <li><a href="#stratum" id="markdown-toc-stratum">Stratum</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

    <ul class="goback"><li><a href="/en/developer-documentation">Return To Overview</a></li></ul>
    <ul class="reportissue"><li><a href="https://github.com/bitcoin-dot-org/bitcoin.org/issues/new" onmouseover="updateIssue(event);">Report An Issue</a></li></ul>
    <ul class="editsource"><li><a href="https://github.com/bitcoin-dot-org/bitcoin.org/tree/master/_includes" onmouseover="updateSource(event);">Edit On GitHub</a></li></ul>

  </div>
</div>

<div class="toccontent">

  <!-- includes should be separated by an empty line to prevent a
paragraph at the end of one file from breaking the heading at the start
of the following file. -->

  <!--Temporary disclaimer BEGIN-->
  <div id="develdocdisclaimer" class="develdocdisclaimer"><div>
<b>BETA</b>: This documentation has not been extensively reviewed by Dash experts and so likely contains numerous errors. Please use the <em>Issue</em> and <em>Edit</em> links on the bottom left menu to help us improve.  <a href="#" onclick="disclaimerClose(event);">Click here</a> to close this disclaimer.
<a class="develdocdisclaimerclose" onclick="disclaimerClose(event);">X</a>
</div></div>
  <script>disclaimerAutoClose();</script>

  <!--Temporary disclaimer END-->

  <p><input id="glossary_term" class="glossary_term" placeholder="Search the glossary, RPCs, and more" /></p>

  <p>The Developer Guide aims to provide the information you need to understand
Bitcoin and start building Bitcoin-based applications, but it is <a href="/en/developer-reference#not-a-specification">not a
specification</a>. To make the best use of
this documentation, you may want to install the current version of Bitcoin
Core, either from <a href="https://github.com/dashpay/dash/">source</a> or from a <a href="https://www.dash.org/wallets/#wallets">pre-compiled executable</a>.</p>

  <p>Questions about Bitcoin development are best asked in one of the
<a href="https://www.dash.org/community/">Bitcoin development communities</a>.
Errors or suggestions related to
documentation on Bitcoin.org can be <a href="https://github.com/thephez/dash.org/issues">submitted as an issue</a>
or posted to the [bitcoin-documentation mailing list][].</p>

  <p>In the following documentation, some strings have been shortened or wrapped: “[…]”
indicates extra data was removed, and lines ending in a single backslash “\”
are continued below. If you hover your mouse over a paragraph, cross-reference
links will be shown in blue.  If you hover over a cross-reference link, a brief
definition of the term will be displayed in a tooltip.</p>

  <h2 id="block-chain">Block Chain</h2>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_block_chain.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_block_chain.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_block_chain.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_block_chain.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The block chain provides Bitcoin’s public ledger, an ordered and timestamped record
of transactions. This system is used to protect against double spending
and modification of previous transaction records.</p>

  <p>Each full node in the Bitcoin network independently stores a block chain
containing only blocks validated by that node. When several nodes all
have the same blocks in their block chain, they are considered to be in
<a href="/en/glossary/consensus" title="When several nodes (usually most nodes on the network) all have the same blocks in their locally-validated best block chain." id="term-consensus" class="term">consensus</a>. The validation rules these
nodes follow to maintain consensus are called <a href="/en/glossary/consensus-rules" title="The block validation rules that full nodes follow to stay in consensus with other nodes." id="term-consensus-rules" class="term">consensus
rules</a>. This section describes many of
the consensus rules used by Bitcoin Core.</p>

  <h3 id="block-chain-overview">Block Chain Overview</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_block_chain.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_block_chain.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_block_chain.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_block_chain.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p><img src="/img/dev/en-blockchain-overview.svg" alt="Block Chain Overview" /></p>

  <p>The illustration above shows a simplified version of a block chain.
A <a href="/en/glossary/block" title="One or more transactions prefaced by a block header and protected by proof of work. Blocks are the data stored on the block chain." id="term-block" class="term">block</a> of one or more new transactions
is collected into the transaction data part of a block.
Copies of each transaction are hashed, and the hashes are then paired,
hashed, paired again, and hashed again until a single hash remains, the
<a href="/en/glossary/merkle-root" title="The root node of a merkle tree, a descendant of all the hashed pairs in the tree.  Block headers must include a valid merkle root descended from all transactions in that block." id="term-merkle-root" class="term">merkle root</a> of a merkle tree.</p>

  <p>The merkle root is stored in the block header. Each block also
stores the hash of the previous block’s header, chaining the blocks
together. This ensures a transaction cannot be modified without
modifying the block that records it and all following blocks.</p>

  <p>Transactions are also chained together. Bitcoin wallet software gives
the impression that satoshis are sent from and to wallets, but
bitcoins really move from transaction to transaction. Each
transaction spends the satoshis previously received in one or more earlier
transactions, so the input of one transaction is the output of a
previous transaction.</p>

  <p><img src="/img/dev/en-transaction-propagation.svg" alt="Transaction Propagation" /></p>

  <p>A single transaction can create multiple outputs, as would be
the case when sending to multiple addresses, but each output of
a particular transaction can only be used as an input once in the
block chain. Any subsequent reference is a forbidden double
spend—an attempt to spend the same satoshis twice.</p>

  <p>Outputs are tied to <a href="/en/glossary/txid" title="An identifier used to uniquely identify a particular transaction; specifically, the sha256d hash of the transaction." id="term-txid" class="term">transaction identifiers (TXIDs)</a>, which are the hashes
of signed transactions.</p>

  <p>Because each output of a particular transaction can only be spent once,
the outputs of all transactions included in the block chain can be categorized as either
<a href="/en/glossary/unspent-transaction-output" title="An Unspent Transaction Output (UTXO) that can be spent as an input in a new transaction." id="term-utxo" class="term">Unspent Transaction Outputs (UTXOs)</a> or spent transaction outputs. For a
payment to be valid, it must only use UTXOs as inputs.</p>

  <p>Ignoring coinbase transactions (described later), if the value of a
transaction’s outputs exceed its inputs, the transaction will be
rejected—but if the inputs exceed the value of the outputs, any
difference in value may be claimed as a <a href="/en/glossary/transaction-fee" title="The amount remaining when the value of all outputs in a transaction are subtracted from all inputs in a transaction; the fee is paid to the miner who includes that transaction in a block." id="term-transaction-fee" class="term">transaction
fee</a> by the Bitcoin
<a href="/en/glossary/mining" title="Mining is the act of creating valid Bitcoin blocks, which requires demonstrating proof of work, and miners are devices that mine or people who own those devices." id="term-miner" class="term">miner</a> who creates the block containing that
transaction.
For example, in the illustration above, each transaction spends 10,000 satoshis
fewer than it receives from its combined inputs, effectively paying a 10,000
satoshi transaction fee.</p>

  <h3 id="proof-of-work">Proof Of Work</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_block_chain.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_block_chain.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_block_chain.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_block_chain.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The block chain is collaboratively maintained by anonymous peers on the network, so
Bitcoin requires that each block prove a significant amount of work was invested in
its creation to ensure that untrustworthy peers who want to modify past blocks have
to work harder than honest peers who only want to add new blocks to the
block chain.</p>

  <p>Chaining blocks together makes it impossible to modify transactions included
in any block without modifying all following blocks. As a
result, the cost to modify a particular block increases with every new block
added to the block chain, magnifying the effect of the proof of work.</p>

  <p>The <a href="/en/glossary/proof-of-work" title="A hash below a target value which can only be obtained, on average, by performing a certain amount of brute force work---therefore demonstrating proof of work." id="term-proof-of-work" class="term">proof of work</a> used in Bitcoin
takes advantage of the apparently random nature of cryptographic hashes.
A good cryptographic hash algorithm converts arbitrary data into a
seemingly-random number. If the data is modified in any way and
the hash re-run, a new seemingly-random number is produced, so there is
no way to modify the data to make the hash number predictable.</p>

  <p>To prove you did some extra work to create a block, you must create a
hash of the block header which does not exceed a certain value. For
example, if the maximum possible hash value is <span class="math">2<sup>256</sup> − 1</span>, you can prove that you
tried up to two combinations by producing a hash value less than <span class="math">2<sup>255</sup></span>.</p>

  <p>In the example given above, you will produce a successful hash on average every other try.
You can even estimate the probability
that a given hash attempt will generate a number below the <a href="/en/glossary/nbits" title="The target is the threshold below which a block header hash must be in order for the block to valid, and nBits is the encoded form of the target threshold as it appears in the block header." id="term-target" class="term">target</a>
threshold.
Bitcoin assumes a linear probability that the lower it makes the target threshold, the more hash attempts (on average) will need to be tried.</p>

  <p>New blocks will only be added to the block chain if their hash is at
least as challenging as a <a href="/en/glossary/difficulty" title="How difficult it is to find a block relative to the difficulty of finding the easiest possible block. The easiest possible block has a proof-of-work difficulty of 1." id="term-difficulty" class="term">difficulty</a> value expected by the consensus protocol.
Every 2,016 blocks, the network uses timestamps stored in each
block header to calculate the number of seconds elapsed between generation
of the first and last of those last 2,016 blocks. The ideal value is
1,209,600 seconds (two weeks).</p>

  <ul>
    <li>
      <p>If it took fewer than two weeks to generate the 2,016 blocks,
the expected difficulty value is increased proportionally (by as much
as 300%) so that the next 2,016 blocks should take exactly two weeks
to generate if hashes are checked at the same rate.</p>
    </li>
    <li>
      <p>If it took more than two weeks to generate the blocks, the expected
difficulty value is decreased proportionally (by as much as 75%) for
the same reason.</p>
    </li>
  </ul>

  <p>(Note: an off-by-one error in the Bitcoin Core implementation causes the
difficulty to be updated every 2,01<em>6</em> blocks using timestamps from only
2,01<em>5</em> blocks, creating a slight skew.)</p>

  <p>Because each block header must hash to a value below the target
threshold, and because each block is linked to the block that
preceded it, it requires (on average) as much hashing power to
propagate a modified block as the entire Bitcoin network expended
between the time the original block was created and the present time.
Only if you acquired a majority of the network’s hashing power
could you reliably execute such a <a href="/en/glossary/51-percent-attack" title="The ability of someone controlling a majority of network hash rate to revise transaction history and prevent new transactions from confirming." id="term-51-attack" class="term">51 percent attack</a> against
transaction history (although, it should be noted, that even less than 50% of the hashing power still has a good chance of performing such attacks).</p>

  <p>The block header provides several easy-to-modify fields, such as a
dedicated nonce field, so obtaining new hashes doesn’t require waiting
for new transactions. Also, only the 80-byte block header is hashed for
proof-of-work, so including a large volume of transaction data in
a block does not slow down hashing with extra I/O, and adding additional
transaction data only requires the recalculation of the ancestor hashes in
the merkle tree.</p>

  <h3 id="block-height-and-forking">Block Height And Forking</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_block_chain.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_block_chain.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_block_chain.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_block_chain.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Any Bitcoin miner who successfully hashes a block header to a value
below the target threshold can add the entire block to the block chain
(assuming the block is otherwise valid).
These blocks are commonly addressed
by their <a href="/en/glossary/block-height" title="The number of blocks preceding a particular block on a block chain. For example, the genesis block has a height of zero because zero block preceded it." id="term-block-height" class="term">block height</a>—the number of blocks between them and the first Bitcoin
block (block 0, most commonly known as the <a href="/en/glossary/genesis-block" title="The first block in the Bitcoin block chain." id="term-genesis-block" class="term">genesis block</a>). For example,
block 2016 is where difficulty could have first been adjusted.</p>

  <p><img src="/img/dev/en-blockchain-fork.svg" alt="Common And Uncommon Block Chain Forks" /></p>

  <p>Multiple blocks can all have the same block height, as is common when
two or more miners each produce a block at roughly the same time. This
creates an apparent <a href="/en/glossary/fork" title="When two or more blocks have the same block height, forking the block chain.  Typically occurs when two or more miners find blocks at nearly the same time.  Can also happen as part of an attack." id="term-fork" class="term">fork</a> in the block chain, as shown in the
illustration above.</p>

  <p>When miners produce simultaneous blocks at the end of the block chain, each
node individually chooses which block to accept. In the absence of
other considerations, discussed below, nodes usually use the first
block they see.</p>

  <p>Eventually a miner produces another block which attaches to only one of
the competing simultaneously-mined blocks. This makes that side of
the fork stronger than the other side.
Assuming a fork only contains valid
blocks, normal peers always follow the the most difficult chain
to recreate and throw away <a href="/en/glossary/stale-block" title="Blocks which were successfully mined but which aren't included on the current best block chain, likely because some other block at the same height had its chain extended first." id="term-stale-block" class="term">stale blocks</a> belonging to shorter forks.
(Stale blocks are also sometimes called orphans or orphan blocks<!--noref-->, but
those terms are also used for true orphan blocks without a known parent block.)</p>

  <p>Long-term forks are possible if different miners work at cross-purposes,
such as some miners diligently working to extend the block chain at the
same time other miners are attempting a 51 percent attack to revise
transaction history.</p>

  <p>Since multiple blocks can have the same height during a block chain fork, block
height should not be used as a globally unique identifier. Instead, blocks
are usually referenced by the hash of their header (often with the byte order reversed, and in hexadecimal).</p>

  <h3 id="transaction-data">Transaction Data</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_block_chain.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_block_chain.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_block_chain.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_block_chain.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Every block must include one or more transactions. The first one of these
transactions must be a coinbase transaction, also called a generation transaction, which should collect and
spend the block reward (comprised of a block subsidy and any transaction fees paid by transactions included in this block).</p>

  <p>The UTXO of a coinbase transaction has the special condition that
it cannot be spent (used as an input) for at least 100 blocks. This temporarily
prevents a miner from spending the transaction fees and block reward from a
block that may later be determined to be stale (and therefore the coinbase transaction destroyed) after a block chain fork.</p>

  <p>Blocks are not required to include any non-coinbase transactions, but
miners almost always do include additional transactions in order to
collect their transaction fees.</p>

  <p>All transactions, including the coinbase transaction, are encoded into
blocks in binary rawtransaction format.</p>

  <p>The rawtransaction format is hashed to create the transaction
identifier (txid). From these txids, the <a href="/en/glossary/merkle-tree" title="A tree constructed by hashing paired data (the leaves), then pairing and hashing the results until a single hash remains, the merkle root.  In Bitcoin, the leaves are almost always transactions from a single block." id="term-merkle-tree" class="term">merkle tree</a> is constructed by pairing each
txid with one other txid and then hashing them together. If there are
an odd number of txids, the txid without a partner is hashed with a
copy of itself.</p>

  <p>The resulting hashes themselves are each paired with one other hash and
hashed together. Any hash without a partner is hashed with itself. The
process repeats until only one hash remains, the merkle root.</p>

  <p>For example, if transactions were merely joined (not hashed), a
five-transaction merkle tree would look like the following text diagram:</p>

  <div class="highlighter-rouge"><pre><code>       ABCDEEEE .......Merkle root
      /        \
   ABCD        EEEE
  /    \      /
 AB    CD    EE .......E is paired with itself
/  \  /  \  /
A  B  C  D  E .........Transactions
</code></pre>
  </div>

  <p>As discussed in the Simplified Payment Verification (SPV) subsection,
the merkle tree allows clients to verify for
themselves that a transaction was included in a block by obtaining the
merkle root from a block header and a list of the intermediate hashes
from a full peer. The full peer does not need to be trusted: it is
expensive to fake block headers and the intermediate hashes cannot be faked or
the verification will fail.</p>

  <p>For example, to verify transaction D was added to the
block, an SPV client only needs a copy of the C, AB, and EEEE hashes in addition to the
merkle root; the client doesn’t need to know anything about any of the
other transactions. If the five transactions in this block were all at
the maximum size, downloading the entire block would require over
500,000 bytes—but downloading three hashes plus the block header
requires only 140 bytes.</p>

  <p>Note: If identical txids are found within the same block, there is a possibility that the merkle tree may collide with a block with some or all duplicates removed due to how unbalanced merkle trees are implemented (duplicating the lone hash).
Since it is impractical to have separate transactions with identical txids, this does not impose a burden on honest software, but must be checked if the invalid status of a block is to be cached;
otherwise, a valid block with the duplicates eliminated could have the same merkle root and block hash, but be rejected by the cached invalid outcome, resulting in security bugs such as CVE-2012-2459.</p>

  <h3 id="consensus-rule-changes">Consensus Rule Changes</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_block_chain.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_block_chain.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_block_chain.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_block_chain.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>To maintain consensus, all full nodes validate blocks using the same
consensus rules. However, sometimes the consensus rules are changed to
introduce new features or prevent network abuse. When the new rules are
implemented, there will likely be a period of time when non-upgraded
nodes follow the old rules and upgraded nodes follow the new rules,
creating two possible ways consensus can break:</p>

  <ol>
    <li>
      <p>A block following the new consensus rules is accepted by upgraded
nodes but rejected by non-upgraded nodes. For example, a new
transaction feature is used within a block: upgraded nodes understand
the feature and accept it, but non-upgraded nodes reject it because
it violates the old rules.</p>
    </li>
    <li>
      <p>A block violating the new consensus rules is rejected by upgraded
nodes but accepted by non-upgraded nodes. For example, an abusive
transaction feature is used within a block: upgraded nodes reject it
because it violates the new rules, but non-upgraded nodes accept it
because it follows the old rules.</p>
    </li>
  </ol>

  <p>In the first case, rejection by non-upgraded nodes, mining software
which gets block chain data from those non-upgraded nodes refuses to
build on the same chain as mining software getting data from upgraded
nodes. This creates permanently divergent chains—one for non-upgraded
nodes and one for upgraded nodes—called a <a href="/en/glossary/hard-fork" title="A permanent divergence in the block chain, commonly occurs when non-upgraded nodes can't validate blocks created by upgraded nodes that follow newer consensus rules." id="term-hard-fork" class="term">hard
fork</a>.</p>

  <p><img src="/img/dev/en-hard-fork.svg" alt="Hard Fork" /></p>

  <p>In the second case, rejection by upgraded nodes, it’s possible to keep
the block chain from permanently diverging if upgraded nodes control a
majority of the hash rate. That’s because, in this case, non-upgraded
nodes will accept as valid all the same blocks as upgraded nodes, so the
upgraded nodes can build a stronger chain that the non-upgraded nodes
will accept as the best valid block chain. This is called a <a href="/en/glossary/soft-fork" title="A softfork is a change to the bitcoin protocol  wherein only previously valid blocks/transactions  are made invalid. Since old nodes will recognise  the new blocks as valid, a softfork is backward-compatible." id="term-soft-fork" class="term">soft
fork</a>.</p>

  <p><img src="/img/dev/en-soft-fork.svg" alt="Soft Fork" /></p>

  <p>Although a fork is an actual divergence in block chains, changes to the
consensus rules are often described by their potential to create either
a hard or soft fork. For example, “increasing the block size above 1 MB
requires a hard fork.” In this example, an actual block chain fork is
not required—but it is a possible outcome.</p>

  <p>Consensus rule changes may be activated in various ways. During Bitcoin’s 
first two years, Satoshi Nakamoto performed several soft forks by just 
releasing the backwards-compatible change in a client that began immediately 
enforcing the new rule. Multiple soft forks such as BIP30 have
been activated via a flag day where the new rule began to be enforced at a 
preset time or block height. Such forks activated via a flag day are known as
<a href="/en/glossary/uasf" title="A Soft Fork activated by flag day or node enforcement instead of miner signalling." id="term-uasf" class="term">User Activated Soft Forks</a> (UASF) as
they are dependent on having sufficient users (nodes) to enforce the new rules
after the flag day.</p>

  <p>Later soft forks waited for a majority of hash rate (typically 75% or 95%) 
to signal their readiness for enforcing the new consensus rules. Once the signalling
threshold has been passed, all nodes will begin enforcing the new rules. Such
forks are known as <a href="/en/glossary/masf" title="A Soft Fork activated by through miner signalling." id="term-masf" class="term">Miner Activated Soft Forks</a> (MASF)
as they are dependent on miners for activation.</p>

  <p><strong>Resources:</strong> <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP16</a>, <a href="https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki">BIP30</a>, and <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP34</a> were implemented as
changes which might have lead to soft forks. <a href="https://github.com/bitcoin/bips/blob/master/bip-0050.mediawiki">BIP50</a> describes both an
accidental hard fork, resolved by temporary downgrading the capabilities
of upgraded nodes, and an intentional hard fork when the temporary
downgrade was removed. A document from Gavin Andresen outlines <a href="https://gist.github.com/gavinandresen/2355445">how
future rule changes may be
implemented</a>.</p>

  <h4 id="detecting-forks">Detecting Forks</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_block_chain.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_block_chain.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_block_chain.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_block_chain.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Non-upgraded nodes may use and distribute incorrect information during
both types of forks, creating several situations which could lead to
financial loss. In particular, non-upgraded nodes may relay and accept
transactions that are considered invalid by upgraded nodes and so will
never become part of the universally-recognized best block chain.
Non-upgraded nodes may also refuse to relay blocks or transactions which
have already been added to the best block chain, or soon will be, and so
provide incomplete information.</p>

  <!-- paragraph below based on src/main.cpp CheckForkWarningConditions() -->

  <p>Bitcoin Core includes code that detects a hard fork by looking at block
chain proof of work. If a non-upgraded node receives block chain headers
demonstrating at least six blocks more proof of work than the best chain
it considers valid, the node reports a warning in the <code class="highlighter-rouge">getnetworkinfo</code> RPC
results and runs the <code class="highlighter-rouge">-alertnotify</code> command if set.  This warns the
operator that the non-upgraded node can’t switch to what is likely the
best block chain.</p>

  <p>Full nodes can also check block and transaction version numbers. If the
block or transaction version numbers seen in several recent blocks are
higher than the version numbers the node uses, it can assume it doesn’t
use the current consensus rules. Bitcoin Core reports this situation 
through the <code class="highlighter-rouge">getnetworkinfo</code> RPC and <code class="highlighter-rouge">-alertnotify</code> command if set.</p>

  <p>In either case, block and transaction data should not be relied upon 
if it comes from a node that apparently isn’t using the current 
consensus rules.</p>

  <p>SPV clients which connect to full nodes can detect a likely hard fork by
connecting to several full nodes and ensuring that they’re all on the
same chain with the same block height, plus or minus several blocks to
account for transmission delays and stale blocks.  If there’s a
divergence, the client can disconnect from nodes with weaker chains.</p>

  <p>SPV clients should also monitor for block and transaction version number
increases to ensure they process received transactions and create new
transactions using the current consensus rules.</p>

  <h2 id="transactions">Transactions</h2>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <!-- reference tx (made by Satoshi in block 170):
    bitcoind decoderawtransaction $( bitcoind getrawtransaction f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16 )
-->

  <!-- SOMEDAY: we need more terms than just output/input to denote the
various ways the outputs/inputs are used, such as "prevout", "nextout",
"curout", "curin", "nextin".  (Is there any use for "previn"?)  Someday,
when I'm terribly bored, I should rewrite this whole transaction section
to use those terms and then get feedback to see if it actually helps. -harding -->

  <p>Transactions let users spend satoshis. Each transaction is constructed
out of several parts which enable both simple direct payments and complex
transactions. This section will describe each part and
demonstrate how to use them together to build complete transactions.</p>

  <p>To keep things simple, this section pretends coinbase transactions do
not exist. Coinbase transactions can only be created by Bitcoin miners
and they’re an exception to many of the rules listed below. Instead of
pointing out the coinbase exception to each rule, we invite you to read
about coinbase transactions in the block chain section of this guide.</p>

  <p><img src="/img/dev/en-tx-overview.svg" alt="The Parts Of A Transaction" /></p>

  <p>The figure above shows the main parts of a Bitcoin transaction. Each
transaction has at least one input and one output. Each <a href="/en/glossary/input" title="An input in a transaction which contains three fields: an outpoint, a signature script, and a sequence number.  The outpoint references a previous output and the signature script allows spending it." id="term-input" class="term">input</a> spends the
satoshis paid to a previous output. Each <a href="/en/glossary/output" title="An output in a transaction which contains two fields: a value field for transferring zero or more satoshis and a pubkey script for indicating what conditions must be fulfilled for those satoshis to be further spent." id="term-output" class="term">output</a> then waits as an Unspent
Transaction Output (UTXO) until a later input spends it. When your
Bitcoin wallet tells you that you have a 10,000 satoshi balance, it really
means that you have 10,000 satoshis waiting in one or more UTXOs.</p>

  <p>Each transaction is prefixed by a four-byte <a href="/en/developer-guide#term-transaction-version-number" title="A version number prefixed to transactions to allow upgrading&quot;" id="term-transaction-version-number" class="term">transaction version number</a> which tells
Bitcoin peers and miners which set of rules to use to validate it.  This
lets developers create new rules for future transactions without
invalidating previous transactions.</p>

  <p><img src="/img/dev/en-tx-overview-spending.svg" alt="Spending An Output" /></p>

  <p>An output has an implied index number based on its location in the
transaction—the first output is output zero. The output also has an
amount in satoshis which it pays to a conditional pubkey script. Anyone
who can satisfy the conditions of that pubkey script can spend up to the
amount of satoshis paid to it.</p>

  <p>An input uses a transaction identifier (txid) and an output index number
(often called “vout” for output vector) to identify a particular output to
be spent. It also has a signature script which allows it to provide data
parameters that satisfy the conditionals in the pubkey script. (The sequence
number and locktime are related and will be covered together in
a later subsection.)</p>

  <p>The figures below help illustrate how these features are used by
showing the workflow Alice uses to send Bob a transaction and which Bob
later uses to spend that transaction. Both Alice and Bob will use the
most common form of the standard Pay-To-Public-Key-Hash (P2PKH) transaction
type. <a href="/en/glossary/p2pkh-address" title="A Bitcoin payment address comprising a hashed public key, allowing the spender to create a standard pubkey script that Pays To PubKey Hash (P2PKH)." id="term-p2pkh" class="term">P2PKH</a> lets Alice spend satoshis to a typical Bitcoin address,
and then lets Bob further spend those satoshis using a simple
cryptographic key pair.</p>

  <p><img src="/img/dev/en-creating-p2pkh-output.svg" alt="Creating A P2PKH Public Key Hash To Receive Payment" /></p>

  <p>Bob must first generate a private/public <a href="/en/developer-guide#term-key-pair" title="A private key and its derived public key" id="term-key-pair" class="term">key pair</a> before Alice can create the
first transaction. Bitcoin uses the Elliptic Curve Digital Signature Algorithm (ECDSA) with
the secp256k1 curve; secp256k1 <a href="/en/glossary/private-key" title="The private portion of a keypair which can create signatures that other people can verify using the public key." id="term-private-key" class="term">private keys</a> are 256 bits of random
data. A copy of that data is deterministically transformed into an secp256k1 <a href="/en/glossary/public-key" title="The public portion of a keypair which can be used to verify signatures made with the private portion of the keypair." id="term-public-key" class="term">public
key</a>. Because the transformation can be reliably repeated later, the
public key does not need to be stored.</p>

  <p>The public key (pubkey) is then cryptographically hashed. This pubkey hash can
also be reliably repeated later, so it also does not need to be stored.
The hash shortens and obfuscates the public key, making manual
transcription easier and providing security against
unanticipated problems which might allow reconstruction of private keys
from public key data at some later point.</p>

  <!-- Editors: from here on I will typically use the terms "pubkey hash"
and "full public key" to provide quick differentiation between the
different states of a public key and to help the text better match the
space-constrained diagrams where "public-key hash" wouldn't fit. -harding -->

  <p>Bob provides the pubkey hash to Alice. Pubkey hashes are almost always
sent encoded as Bitcoin <a href="/en/glossary/address" title="A 20-byte hash formatted using base58check to produce either a P2PKH or P2SH Bitcoin address.  Currently the most common way users exchange payment information." id="term-address" class="term">addresses</a>, which are base58-encoded strings
containing an address version number, the hash, and an error-detection
checksum to catch typos. The address can be transmitted
through any medium, including one-way mediums which prevent the spender
from communicating with the receiver, and it can be further encoded
into another format, such as a QR code containing a <code class="highlighter-rouge">bitcoin:</code>
URI.</p>

  <p>Once Alice has the address and decodes it back into a standard hash, she
can create the first transaction. She creates a standard P2PKH
transaction output containing instructions which allow anyone to spend that
output if they can prove they control the private key corresponding to
Bob’s hashed public key. These instructions are called the <a href="/en/glossary/pubkey-script" title="A script included in outputs which sets the conditions that must be fulfilled for those satoshis to be spent.  Data for fulfilling the conditions can be provided in a signature script. Pubkey Scripts are called a scriptPubKey in code." id="term-pubkey-script" class="term">pubkey script</a>
or scriptPubKey.</p>

  <p>Alice broadcasts the transaction and it is added to the block chain.
The network categorizes it as an Unspent Transaction Output (UTXO), and Bob’s
wallet software displays it as a spendable balance.</p>

  <p>When, some time later, Bob decides to spend the UTXO, he must create an
input which references the transaction Alice created by its hash, called
a Transaction Identifier (txid), and the specific output she used by its
index number (<a href="/en/developer-guide#term-output-index" title="The sequentially-numbered index of outputs in a single transaction starting from 0" id="term-output-index" class="term">output index</a>). He must then create a <a href="/en/glossary/signature-script" title="Data generated by a spender which is almost always used as variables to satisfy a pubkey script. Signature Scripts are called scriptSig in code." id="term-signature-script" class="term">signature
script</a>—a
collection of data parameters which satisfy the conditions Alice placed
in the previous output’s pubkey script.  Signature scripts are also
called scriptSigs.</p>

  <p>Pubkey scripts and signature scripts combine secp256k1 pubkeys
and signatures with conditional logic, creating a programmable
authorization mechanism.</p>

  <p><img src="/img/dev/en-unlocking-p2pkh-output.svg" alt="Unlocking A P2PKH Output For Spending" /></p>

  <p>For a P2PKH-style output, Bob’s signature script will contain the following two
pieces of data:</p>

  <ol>
    <li>
      <p>His full (unhashed) public key, so the pubkey script can check that it
hashes to the same value as the pubkey hash provided by Alice.</p>
    </li>
    <li>
      <p>An secp256k1 <a href="/en/glossary/signature" title="A value related to a public key which could only have reasonably been created by someone who has the private key that created that public key. Used in Bitcoin to authorize spending satoshis previously sent to a public key." id="term-signature" class="term">signature</a> made by using the ECDSA cryptographic formula to combine
certain transaction data (described below) with Bob’s private key.
This lets the pubkey script verify that Bob owns the private key which
created the public key.</p>
    </li>
  </ol>

  <p>Bob’s secp256k1 signature doesn’t just prove Bob controls his private key; it also
makes the non-signature-script parts of his transaction tamper-proof so Bob can safely
broadcast them over the peer-to-peer network.</p>

  <p><img src="/img/dev/en-signing-output-to-spend.svg" alt="Some Things Signed When Spending An Output" /></p>

  <p>As illustrated in the figure above, the data Bob signs includes the
txid and output index of the previous transaction, the previous
output’s pubkey script, the pubkey script Bob creates which will let the next
recipient spend this transaction’s output, and the amount of satoshis to
spend to the next recipient. In essence, the entire transaction is
signed except for any signature scripts, which hold the full public keys and
secp256k1 signatures.</p>

  <p>After putting his signature and public key in the signature script, Bob
broadcasts the transaction to Bitcoin miners through the peer-to-peer
network. Each peer and miner independently validates the transaction
before broadcasting it further or attempting to include it in a new block of
transactions.</p>

  <h3 id="p2pkh-script-validation">P2PKH Script Validation</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The validation procedure requires evaluation of the signature script and pubkey script.
In a P2PKH output, the pubkey script is:</p>

  <div class="highlighter-rouge"><pre><code>OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>
  </div>

  <p>The spender’s signature script is evaluated and prefixed to the beginning of the
script. In a P2PKH transaction, the signature script contains an secp256k1 signature (sig)
and full public key (pubkey), creating the following concatenation:</p>

  <div class="highlighter-rouge"><pre><code>&lt;Sig&gt; &lt;PubKey&gt; OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>
  </div>

  <p>The script language is a
<a href="https://en.wikipedia.org/wiki/Forth_%28programming_language%29">Forth-like</a>
stack-based language deliberately designed to be stateless and not
Turing complete. Statelessness ensures that once a transaction is added
to the block chain, there is no condition which renders it permanently
unspendable. Turing-incompleteness (specifically, a lack of loops or
gotos) makes the script language less flexible and more predictable,
greatly simplifying the security model.</p>

  <!-- Editors: please do not substitute for the words push or pop in
sections about stacks. These are programming terms. Also "above",
"below", "top", and "bottom" are commonly used relative directions or
locations in stack descriptions. -harding -->

  <p>To test whether the transaction is valid, signature script and pubkey script operations
are executed one item at a time, starting with Bob’s signature script
and continuing to the end of Alice’s pubkey script. The figure below shows the
evaluation of a standard P2PKH pubkey script; below the figure is a description
of the process.</p>

  <p><img src="/img/dev/en-p2pkh-stack.svg" alt="P2PKH Stack Evaluation" /></p>

  <ul>
    <li>
      <p>The signature (from Bob’s signature script) is added (pushed) to an empty stack.
Because it’s just data, nothing is done except adding it to the stack.
The public key (also from the signature script) is pushed on top of the signature.</p>
    </li>
    <li>
      <p>From Alice’s pubkey script, the <code class="highlighter-rouge">OP_DUP</code> operation is executed. <code class="highlighter-rouge">OP_DUP</code> pushes onto the stack
a copy of the data currently at the top of it—in this
case creating a copy of the public key Bob provided.</p>
    </li>
    <li>
      <p>The operation executed next, <code class="highlighter-rouge">OP_HASH160</code>, pushes onto the stack a hash
of the data currently on top of it—in this case, Bob’s public key.
This creates a hash of Bob’s public key.</p>
    </li>
    <li>
      <p>Alice’s pubkey script then pushes the pubkey hash that Bob gave her for the
first transaction.  At this point, there should be two copies of Bob’s
pubkey hash at the top of the stack.</p>
    </li>
    <li>
      <p>Now it gets interesting: Alice’s pubkey script executes <code class="highlighter-rouge">OP_EQUALVERIFY</code>.
<code class="highlighter-rouge">OP_EQUALVERIFY</code> is equivalent to executing <code class="highlighter-rouge">OP_EQUAL</code> followed by <code class="highlighter-rouge">OP_VERIFY</code> (not shown).</p>

      <p><code class="highlighter-rouge">OP_EQUAL</code> (not shown) checks the two values at the top of the stack; in this
  case, it checks whether the pubkey hash generated from the full
  public key Bob provided equals the pubkey hash Alice provided when
  she created transaction #1. <code class="highlighter-rouge">OP_EQUAL</code> pops (removes from the top of the stack)
  the two values it compared, and replaces them with the result of that comparison:
  zero (<em>false</em>) or one (<em>true</em>).</p>

      <p><code class="highlighter-rouge">OP_VERIFY</code> (not shown) checks the value at the top of the stack. If
  the value is <em>false</em> it immediately terminates evaluation and
  the transaction validation fails. Otherwise it pops the <em>true</em> value off the stack.</p>
    </li>
    <li>
      <p>Finally, Alice’s pubkey script executes <code class="highlighter-rouge">OP_CHECKSIG</code>, which checks the
signature Bob provided against the now-authenticated public key he
also provided. If the signature matches the public key and was
generated using all of the data required to be signed, <code class="highlighter-rouge">OP_CHECKSIG</code>
pushes the value <em>true</em> onto the top of the stack.</p>
    </li>
  </ul>

  <p>If <em>false</em> is not at the top of the stack after the pubkey script has been
evaluated, the transaction is valid (provided there are no other
problems with it).</p>

  <h3 id="p2sh-scripts">P2SH Scripts</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Pubkey scripts are created by spenders who have little interest what
that script does. Receivers do care about the script conditions and, if
they want, they can ask spenders to use a particular pubkey script.
Unfortunately, custom pubkey scripts are less convenient than short
Bitcoin addresses and there was no standard way to communicate them
between programs prior to widespread implementation of the BIP70 Payment
Protocol discussed later.</p>

  <p>To solve these problems, pay-to-script-hash
(<a href="/en/glossary/p2sh-address" title="A Bitcoin payment address comprising a hashed script, allowing the spender to create a standard pubkey script that Pays To Script Hash (P2SH). The script can be almost any valid pubkey script." id="term-p2sh" class="term">P2SH</a>) transactions were created in 2012 to let
a spender create a pubkey script containing a hash of a second
script, the
<a href="/en/glossary/redeem-script" title="A script similar in function to a pubkey script. One copy of it is hashed to create a P2SH address (used in an actual pubkey script) and another copy is placed in the spending signature script to enforce its conditions." id="term-redeem-script" class="term">redeem script</a>.</p>

  <p>The basic P2SH workflow, illustrated below, looks almost identical to
the P2PKH workflow. Bob creates a redeem script with whatever script he
wants, hashes the redeem script, and provides the redeem script
hash to Alice. Alice creates a P2SH-style output containing
Bob’s redeem script hash.</p>

  <p><img src="/img/dev/en-creating-p2sh-output.svg" alt="Creating A P2SH Redeem Script And Hash" /></p>

  <p>When Bob wants to spend the output, he provides his signature along with
the full (serialized) redeem script in the signature script. The
peer-to-peer network ensures the full redeem script hashes to the same
value as the script hash Alice put in her output; it then processes the
redeem script exactly as it would if it were the primary pubkey script, letting
Bob spend the output if the redeem script does not return false.</p>

  <p><img src="/img/dev/en-unlocking-p2sh-output.svg" alt="Unlocking A P2SH Output For Spending" /></p>

  <p>The hash of the redeem script has the same properties as a pubkey
hash—so it can be transformed into the standard Bitcoin address format
with only one small change to differentiate it from a standard address.
This makes collecting a P2SH-style address as simple as collecting a
P2PKH-style address. The hash also obfuscates any public keys in the
redeem script, so P2SH scripts are as secure as P2PKH pubkey hashes.</p>

  <h3 id="standard-transactions">Standard Transactions</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>After the discovery of several dangerous bugs in early versions of
Bitcoin, a test was added which only accepted transactions from the
network if their pubkey scripts and signature scripts matched a small set of
believed-to-be-safe templates, and if the rest of the transaction didn’t
violate another small set of rules enforcing good network behavior. This
is the <code class="highlighter-rouge">IsStandard()</code> test, and transactions which pass it are called
standard transactions.</p>

  <p>Non-standard transactions—those that fail the test—may be accepted
by nodes not using the default Bitcoin Core settings. If they are
included in blocks, they will also avoid the IsStandard test and be
processed.</p>

  <p>Besides making it more difficult for someone to attack Bitcoin for
free by broadcasting harmful transactions, the standard transaction
test also helps prevent users from creating transactions today that
would make adding new transaction features in the future more
difficult. For example, as described above, each transaction includes
a version number—if users started arbitrarily changing the version
number, it would become useless as a tool for introducing
backwards-incompatible features.</p>

  <p>As of Bitcoin Core 0.9, the standard pubkey script types are:</p>

  <h4 class="no_toc" id="pay-to-public-key-hash-p2pkh">Pay To Public Key Hash (P2PKH)</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>P2PKH is the most common form of pubkey script used to send a transaction to one
or multiple Bitcoin addresses.</p>

  <div class="highlighter-rouge"><pre><code>Pubkey script: OP_DUP OP_HASH160 &lt;PubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
Signature script: &lt;sig&gt; &lt;pubkey&gt;
</code></pre>
  </div>

  <h4 class="no_toc" id="pay-to-script-hash-p2sh">Pay To Script Hash (P2SH)</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>P2SH is used to send a transaction to a script hash. Each of the standard
pubkey scripts can be used as a P2SH redeem script, but in practice only the
multisig pubkey script makes sense until more transaction types are made standard.</p>

  <div class="highlighter-rouge"><pre><code>Pubkey script: OP_HASH160 &lt;Hash160(redeemScript)&gt; OP_EQUAL
Signature script: &lt;sig&gt; [sig] [sig...] &lt;redeemScript&gt;
</code></pre>
  </div>

  <h4 class="no_toc" id="multisig">Multisig</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Although P2SH multisig is now generally used for multisig transactions, this base script
can be used to require multiple signatures before a UTXO can be spent.</p>

  <p>In multisig pubkey scripts, called m-of-n, <em>m</em> is the <em>minimum</em> number of signatures
which must match a public key; <em>n</em> is the <em>number</em> of public keys being
provided. Both <em>m</em> and <em>n</em> should be opcodes <code class="highlighter-rouge">OP_1</code> through <code class="highlighter-rouge">OP_16</code>,
corresponding to the number desired.</p>

  <p>Because of an off-by-one error in the original Bitcoin implementation
which must be preserved for compatibility, <code class="highlighter-rouge">OP_CHECKMULTISIG</code>
consumes one more value from the stack than indicated by <em>m</em>, so the
list of secp256k1 signatures in the signature script must be prefaced with an extra value
(<code class="highlighter-rouge">OP_0</code>) which will be consumed but not used.</p>

  <p>The signature script must provide signatures in the same order as the
corresponding public keys appear in the pubkey script or redeem
script. See the description in <a href="/en/developer-reference#term-op-checkmultisig" title="Opcode which returns true if one or more provided signatures (m) sign the correct parts of a transaction and match one or more provided public keys (n)"><code class="highlighter-rouge">OP_CHECKMULTISIG</code></a>
for details.</p>

  <div class="highlighter-rouge"><pre><code>Pubkey script: &lt;m&gt; &lt;A pubkey&gt; [B pubkey] [C pubkey...] &lt;n&gt; OP_CHECKMULTISIG
Signature script: OP_0 &lt;A sig&gt; [B sig] [C sig...]
</code></pre>
  </div>

  <p>Although it’s not a separate transaction type, this is a P2SH multisig with 2-of-3:</p>

  <div class="highlighter-rouge"><pre><code>Pubkey script: OP_HASH160 &lt;Hash160(redeemScript)&gt; OP_EQUAL
Redeem script: &lt;OP_2&gt; &lt;A pubkey&gt; &lt;B pubkey&gt; &lt;C pubkey&gt; &lt;OP_3&gt; OP_CHECKMULTISIG
Signature script: OP_0 &lt;A sig&gt; &lt;C sig&gt; &lt;redeemScript&gt;
</code></pre>
  </div>

  <h4 class="no_toc" id="pubkey">Pubkey</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Pubkey outputs are a simplified form of the P2PKH pubkey script,
but they aren’t as
secure as P2PKH, so they generally
aren’t used in new transactions anymore.</p>

  <div class="highlighter-rouge"><pre><code>Pubkey script: &lt;pubkey&gt; OP_CHECKSIG
Signature script: &lt;sig&gt;
</code></pre>
  </div>

  <h4 class="no_toc" id="null-data">Null Data</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p><a href="/en/glossary/null-data-transaction" title="A transaction type relayed and mined by default in Bitcoin Core 0.9.0 and later that adds arbitrary data to a provably unspendable pubkey script that full nodes don't have to store in their UTXO database." id="term-null-data" class="term">Null data</a>
transaction type relayed and mined by default in Bitcoin Core 0.9.0 and
later that adds arbitrary data to a provably unspendable pubkey script
that full nodes don’t have to store in their UTXO database. It is
preferable to use null data transactions over transactions that bloat
the UTXO database because they cannot be automatically pruned; however,
it is usually even more preferable to store data outside transactions
if possible.</p>

  <p>Consensus rules allow null data outputs up to the maximum allowed pubkey
script size of 10,000 bytes provided they follow all other consensus
rules, such as not having any data pushes larger than 520 bytes.</p>

  <p>Bitcoin Core 0.9.x to 0.10.x will, by default, relay and mine null data
transactions with up to 40 bytes in a single data push and only one null
data output that pays exactly 0 satoshis:</p>

  <div class="highlighter-rouge"><pre><code>Pubkey Script: OP_RETURN &lt;0 to 40 bytes of data&gt;
(Null data scripts cannot be spent, so there's no signature script.)
</code></pre>
  </div>

  <p>Bitcoin Core 0.11.x increases this default to 80 bytes, with the other
rules remaining the same.</p>

  <p>Bitcoin Core 0.12.0 defaults
to relaying and mining null data outputs with up to 83 bytes with any
number of data pushes, provided the total byte limit is not exceeded.
There must still only be a single null data output and it must still pay
exactly 0 satoshis.</p>

  <p>The <code class="highlighter-rouge">-datacarriersize</code> Bitcoin Core configuration option allows you to
set the maximum number of bytes in null data outputs that you will relay
or mine.</p>

  <h4 id="non-standard-transactions">Non-Standard Transactions</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>If you use anything besides a standard pubkey script in an output, peers
and miners using the default Bitcoin Core settings will neither
accept, broadcast, nor mine your transaction. When you try to broadcast
your transaction to a peer running the default settings, you will
receive an error.</p>

  <p>If you create a redeem script, hash it, and use the hash
in a P2SH output, the network sees only the hash, so it will accept the
output as valid no matter what the redeem script says.
This allows payment to non-standard scripts, and as of Bitcoin Core
0.11, almost all valid redeem scripts can be spent. The exception is
scripts that use unassigned <a href="https://en.bitcoin.it/wiki/Script#Reserved_words">NOP opcodes</a>; these opcodes are
reserved for future soft forks and can only be relayed or mined by nodes
that don’t follow the standard mempool policy.</p>

  <p>Note: standard transactions are designed to protect and help the
network, not prevent you from making mistakes. It’s easy to create
standard transactions which make the satoshis sent to them unspendable.</p>

  <p>As of Bitcoin Core 0.9.3, standard transactions must also meet the following
conditions:</p>

  <ul>
    <li>
      <p>The transaction must be finalized: either its locktime must be in the
past (or less than or equal to the current block height), or all of its sequence
numbers must be 0xffffffff.</p>
    </li>
    <li>
      <p>The transaction must be smaller than 100,000 bytes. That’s around 200
times larger than a typical single-input, single-output P2PKH
transaction.</p>
    </li>
    <li>
      <p>Each of the transaction’s signature scripts must be smaller than 1,650 bytes.
That’s large enough to allow 15-of-15 multisig transactions in P2SH
using compressed public keys.</p>
    </li>
    <li>
      <p>Bare (non-P2SH) multisig transactions which require more than 3 public keys are
currently non-standard.</p>
    </li>
    <li>
      <p>The transaction’s signature script must only push data to the script
evaluation stack. It cannot push new opcodes, with the exception of
opcodes which solely push data to the stack.</p>
    </li>
    <li>
      <p>The transaction must not include any outputs which receive fewer than
1/3 as many satoshis as it would take to spend it in a typical input.
That’s <a href="https://github.com/bitcoin/bitcoin/commit/6a4c196dd64da2fd33dc7ae77a8cdd3e4cf0eff1">currently 546 satoshis</a> for a
P2PKH or P2SH output on a Bitcoin Core node with the default relay fee.
Exception: standard null data outputs must receive zero satoshis.</p>
    </li>
  </ul>

  <h3 id="signature-hash-types">Signature Hash Types</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p><code class="highlighter-rouge">OP_CHECKSIG</code> extracts a non-stack argument from each signature it
evaluates, allowing the signer to decide which parts of the transaction
to sign. Since the signature protects those parts of the transaction
from modification, this lets signers selectively choose to let other
people modify their transactions.</p>

  <p>The various options for what to sign are
called <a href="/en/glossary/signature-hash" title="A flag to Bitcoin signatures that indicates what parts of the transaction the signature signs.  (The default is SIGHASH_ALL.) The unsigned parts of the transaction may be modified." id="term-signature-hash" class="term">signature hash</a> types. There are three base SIGHASH types
currently available:</p>

  <ul>
    <li>
      <p><a href="/en/glossary/sighash-all" title="Default signature hash type which signs the entire transaction except any signature scripts, preventing modification of the signed parts." id="term-sighash-all" class="term"><code class="highlighter-rouge">SIGHASH_ALL</code></a>, the default, signs all the inputs and outputs,
protecting everything except the signature scripts against modification.</p>
    </li>
    <li>
      <p><a href="/en/glossary/sighash-none" title="Signature hash type which only signs the inputs, allowing anyone to change the outputs however they'd like." id="term-sighash-none" class="term"><code class="highlighter-rouge">SIGHASH_NONE</code></a> signs all of the inputs but none of the outputs,
allowing anyone to change where the satoshis are going unless other
signatures using other signature hash flags protect the outputs.</p>
    </li>
    <li>
      <p><a href="/en/glossary/sighash-single" title="Signature hash type that signs the output corresponding to this input (the one with the same index value), this input, and any other inputs partially. Allows modification of other outputs and the sequence number of other inputs." id="term-sighash-single" class="term"><code class="highlighter-rouge">SIGHASH_SINGLE</code></a>
the only output signed is the one corresponding to this input (the output
with the same output index number as this input), ensuring nobody can change
your part of the transaction but allowing other signers to change their part
of the transaction. The corresponding output must exist or the value “1” will
be signed, breaking the security scheme. This input, as well as other inputs,
are included in the signature. The sequence numbers of other inputs are not
included in the signature, and can be updated.</p>
    </li>
  </ul>

  <p>The base types can be modified with the <a href="/en/glossary/sighash-anyonecanpay" title="A signature hash type which signs only the current input." id="term-sighash-anyonecanpay" class="term"><code class="highlighter-rouge">SIGHASH_ANYONECANPAY</code></a> (anyone can
pay) flag, creating three new combined types:</p>

  <ul>
    <li>
      <p><code class="highlighter-rouge">SIGHASH_ALL|SIGHASH_ANYONECANPAY</code> signs all of the outputs but only
this one input, and it also allows anyone to add or remove other
inputs, so anyone can contribute additional satoshis but they cannot
change how many satoshis are sent nor where they go.</p>
    </li>
    <li>
      <p><code class="highlighter-rouge">SIGHASH_NONE|SIGHASH_ANYONECANPAY</code> signs only this one input and
allows anyone to add or remove other inputs or outputs, so anyone who
gets a copy of this input can spend it however they’d like.</p>
    </li>
    <li>
      <p><code class="highlighter-rouge">SIGHASH_SINGLE|SIGHASH_ANYONECANPAY</code> signs this one input and its
corresponding output. Allows anyone to add or remove other inputs.</p>
    </li>
  </ul>

  <p>Because each input is signed, a transaction with multiple inputs can
have multiple signature hash types signing different parts of the transaction. For
example, a single-input transaction signed with <code class="highlighter-rouge">NONE</code> could have its
output changed by the miner who adds it to the block chain. On the other
hand, if a two-input transaction has one input signed with <code class="highlighter-rouge">NONE</code> and
one input signed with <code class="highlighter-rouge">ALL</code>, the <code class="highlighter-rouge">ALL</code> signer can choose where to spend
the satoshis without consulting the <code class="highlighter-rouge">NONE</code> signer—but nobody else can
modify the transaction.</p>

  <!-- TODO: describe useful combinations maybe using a 3x3 grid;
do something similar for the multisig section with different hashtypes
between different sigs -->

  <!-- TODO: add to the technical section details about what the different
hash types sign, including the procedure for inserting the subscript -->

  <h3 id="locktime-and-sequence-number">Locktime And Sequence Number</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>One thing all signature hash types sign is the transaction’s <a href="/en/glossary/locktime" title="Part of a transaction which indicates the earliest time or earliest block when that transaction may be added to the block chain." id="term-locktime" class="term">locktime</a>.
(Called nLockTime in the Bitcoin Core source code.)
The locktime indicates the earliest time a transaction can be added to
the block chain.</p>

  <p>Locktime allows signers to create time-locked transactions which will
only become valid in the future, giving the signers a chance to change
their minds.</p>

  <p>If any of the signers change their mind, they can create a new
non-locktime transaction. The new transaction will use, as one of
its inputs, one of the same outputs which was used as an input to
the locktime transaction. This makes the locktime transaction
invalid if the new transaction is added to the block chain before
the time lock expires.</p>

  <p>Care must be taken near the expiry time of a time lock. The peer-to-peer
network allows block time to be up to two hours ahead of
real time, so a locktime transaction can be added to the block chain up
to two hours before its time lock officially expires. Also, blocks are
not created at guaranteed intervals, so any attempt to cancel a valuable
transaction should be made a few hours before the time lock expires.</p>

  <p>Previous versions of Bitcoin Core provided a feature which prevented
transaction signers from using the method described above to cancel a
time-locked transaction, but a necessary part of this feature was
disabled to prevent denial of service attacks. A legacy of this system are four-byte
<a href="/en/glossary/sequence-number" title="Part of all transactions. A number intended to allow unconfirmed time-locked transactions to be updated before being finalized; not currently used except to disable locktime in a transaction" id="term-sequence-number" class="term">sequence numbers</a> in every input. Sequence numbers were meant to allow
multiple signers to agree to update a transaction; when they finished
updating the transaction, they could agree to set every input’s
sequence number to the four-byte unsigned maximum (0xffffffff),
allowing the transaction to be added to a block even if its time lock
had not expired.</p>

  <p>Even today, setting all sequence numbers to 0xffffffff (the default in
Bitcoin Core) can still disable the time lock, so if you want to use
locktime, at least one input must have a sequence number below the
maximum. Since sequence numbers are not used by the network for any
other purpose, setting any sequence number to zero is sufficient to
enable locktime.</p>

  <p><span id="locktime_parsing_rules">Locktime itself is an unsigned 4-byte integer which can be parsed two ways:</span></p>

  <ul>
    <li>
      <p>If less than 500 million, locktime is parsed as a block height. The
transaction can be added to any block which has this height or higher.</p>
    </li>
    <li>
      <p>If greater than or equal to 500 million, locktime is parsed using the
Unix epoch time format (the number of seconds elapsed since
1970-01-01T00:00 UTC—currently over 1.395 billion). The transaction
can be added to any block whose block time is greater
than the locktime.</p>
    </li>
  </ul>

  <h3 id="transaction-fees-and-change">Transaction Fees And Change</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Transactions pay fees based on the total byte size of the signed transaction. Fees per byte are calculated based on current demand for space in mined blocks with fees rising as demand increases.  The transaction fee is given to the
Bitcoin miner, as explained in the <a href="/en/developer-guide#block-chain">block chain section</a>, and so it is
ultimately up to each miner to choose the minimum transaction fee they
will accept.</p>

  <p>There is also a concept of so-called “<a href="/en/glossary/high-priority-transaction" title="Transactions that don't have to pay a transaction fee because their inputs have been idle long enough to accumulated large amounts of priority.  Note: miners choose whether to accept free transactions." id="term-high-priority-transactions" class="term">high-priority transactions</a>” which spend satoshis that have not moved for a long time.</p>

  <p>In the past, these “priority” transaction were often exempt from the normal fee requirements. Before Bitcoin Core 0.12, 50 KB of each block would be reserved for these high-priority transactions, however this is now set to 0 KB by default.  After the priority area, all transactions are prioritized based on their fee per byte, with higher-paying transactions being added in sequence until all of the available space is filled. <!-- Consider adding links to blockmaxsize and blockmaxweight options once available in the glossary. --></p>

  <p>As of Bitcoin Core 0.9, a <a href="/en/glossary/minimum-relay-fee" title="The minimum transaction fee a transaction must pay (if it isn't a high-priority transaction) for a full node to relay that transaction to other nodes. There is no one minimum relay fee---each node chooses its own policy." id="term-minimum-fee" class="term">minimum fee</a> (currently 1,000 satoshis) has been required to
broadcast a transaction across the network. Any transaction paying only the minimum fee
should be prepared to wait a long time before there’s enough spare space
in a block to include it. Please see the <a href="/en/developer-guide#verifying-payment">verifying payment section</a>
for why this could be important.</p>

  <p>Since each transaction spends Unspent Transaction Outputs (UTXOs) and
because a UTXO can only be spent once, the full value of the included
UTXOs must be spent or given to a miner as a transaction fee.  Few
people will have UTXOs that exactly match the amount they want to pay,
so most transactions include a change output.</p>

  <p><a href="/en/glossary/change-address" title="An output in a transaction which returns satoshis to the spender, thus preventing too much of the input value from going to transaction fees." id="term-change-output" class="term">Change outputs</a> are regular outputs which spend the surplus satoshis
from the UTXOs back to the spender.  They can reuse the same P2PKH pubkey hash
or P2SH script hash as was used in the UTXO, but for the reasons
described in the <a href="#avoiding-key-reuse">next subsection</a>, it is highly recommended that change
outputs be sent to a new P2PKH or P2SH address.</p>

  <h3 id="avoiding-key-reuse">Avoiding Key Reuse</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>In a transaction, the spender and receiver each reveal to each other all
public keys or addresses used in the transaction. This allows either
person to use the public block chain to track past and future
transactions involving the other person’s same public keys or addresses.</p>

  <p>If the same public key is reused often, as happens when people use
Bitcoin addresses (hashed public keys) as static payment addresses,
other people can easily track the receiving and spending habits of that
person, including how many satoshis they control in known addresses.</p>

  <p>It doesn’t have to be that way. If each public key is used exactly
twice—once to receive a payment and once to spend that payment—the
user can gain a significant amount of financial privacy.</p>

  <p>Even better, using new public keys or <a href="/en/developer-guide#term-unique-address" title="Address which are only used once to protect privacy and increase security" id="term-unique-address" class="term">unique
addresses</a> when accepting payments or creating
change outputs can be combined with other techniques discussed later,
such as CoinJoin or merge avoidance, to make it extremely difficult to
use the block chain by itself to reliably track how users receive and
spend their satoshis.</p>

  <p>Avoiding key reuse can also provide security against attacks which might
allow reconstruction of private keys from public keys (hypothesized) or
from signature comparisons (possible today under certain circumstances
described below, with more general attacks hypothesized).</p>

  <ol>
    <li>
      <p>Unique (non-reused) P2PKH and P2SH addresses protect against the first
type of attack by keeping ECDSA public keys hidden (hashed) until the
first time satoshis sent to those addresses are spent, so attacks
are effectively useless unless they can reconstruct private keys in
less than the hour or two it takes for a transaction to be well
protected by the block chain.</p>
    </li>
    <li>
      <p>Unique (non-reused) private keys protect against the second type of
attack by only generating one signature per private key, so attackers
never get a subsequent signature to use in comparison-based attacks.
Existing comparison-based attacks are only practical today when
insufficient entropy is used in signing or when the entropy used
is exposed by some means, such as a
<a href="https://en.wikipedia.org/wiki/Side_channel_attack">side-channel attack</a>.</p>
    </li>
  </ol>

  <p>So, for both privacy and security, we encourage you to build your
applications to avoid public key reuse and, when possible, to discourage
users from reusing addresses. If your application needs to provide a
fixed URI to which payments should be sent, please see the
<a href="/en/developer-guide#bitcoin-uri"><code class="highlighter-rouge">bitcoin:</code> URI section</a> below.</p>

  <h3 id="transaction-malleability">Transaction Malleability</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_transactions.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_transactions.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_transactions.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_transactions.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>None of Bitcoin’s signature hash types protect the signature script, leaving
the door open for a limited denial of service attack called <a href="/en/glossary/malleability" title="The ability of someone to change (mutate) unconfirmed transactions without making them invalid, which changes the transaction's txid, making child transactions invalid." class="term" id="term-transaction-malleability">transaction
malleability</a>. The signature script
contains the secp256k1 signature, which can’t sign itself, allowing attackers to
make non-functional modifications to a transaction without rendering it
invalid. For example, an attacker can add some data to the signature script
which will be dropped before the previous pubkey script is processed.</p>

  <p>Although the modifications are non-functional—so they do not change
what inputs the transaction uses nor what outputs it pays—they do
change the computed hash of the transaction. Since each transaction
links to previous transactions using hashes as a transaction
identifier (txid), a modified transaction will not have the txid its
creator expected.</p>

  <p>This isn’t a problem for most Bitcoin transactions which are designed to
be added to the block chain immediately. But it does become a problem
when the output from a transaction is spent before that transaction is
added to the block chain.</p>

  <p>Bitcoin developers have been working to reduce transaction malleability
among standard transaction types, one outcome of those efforts is
<a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP 141: Segregated Witness</a>,
which is supported by Bitcoin Core but not activated. At present, new
transactions should not depend on
previous transactions which have not been added to the block chain yet,
especially if large amounts of satoshis are at stake.</p>

  <p>Transaction malleability also affects payment tracking.  Bitcoin Core’s
RPC interface lets you track transactions by their txid—but if that
txid changes because the transaction was modified, it may appear that
the transaction has disappeared from the network.</p>

  <p>Current best practices for transaction tracking dictate that a
transaction should be tracked by the transaction outputs (UTXOs) it
spends as inputs, as they cannot be changed without invalidating the
transaction.</p>

  <!-- TODO/harding: The paragraph above needs practical advice about how
to do that. I'll need to find some time to look at somebody's wallet
code. -harding -->

  <p>Best practices further dictate that if a transaction does seem to
disappear from the network and needs to be reissued, that it be reissued
in a way that invalidates the lost transaction. One method which will
always work is to ensure the reissued payment spends all of the same
outputs that the lost transaction used as inputs.</p>

  <h2 id="contracts">Contracts</h2>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_contracts.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_contracts.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_contracts.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_contracts.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Contracts are
transactions which use the decentralized Bitcoin system to enforce financial
agreements.
Bitcoin contracts can often be crafted to minimize dependency on outside
agents, such as the court system, which significantly decreases the risk
of dealing with unknown entities in financial transactions.</p>

  <p>The following subsections will describe a variety of Bitcoin contracts
already in use. Because contracts deal with real people, not just
transactions, they are framed below in story format.</p>

  <p>Besides the contract types described below, many other contract types
have been proposed. Several of them are collected on the <a href="https://en.bitcoin.it/wiki/Contracts">Contracts
page</a> of the Bitcoin Wiki.</p>

  <h3 id="escrow-and-arbitration">Escrow And Arbitration</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_contracts.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_contracts.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_contracts.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_contracts.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Charlie-the-customer wants to buy a product from Bob-the-businessman,
but neither of them trusts the other person, so they use a contract to
help ensure Charlie gets his merchandise and Bob gets his payment.</p>

  <p>A simple contract could say that Charlie will spend satoshis to an
output which can only be spent if Charlie and Bob both sign the input
spending it. That means Bob won’t get paid unless Charlie gets his
merchandise, but Charlie can’t get the merchandise and keep his payment.</p>

  <p>This simple contract isn’t much help if there’s a dispute, so Bob and
Charlie enlist the help of Alice-the-arbitrator to create an <a href="/en/glossary/escrow-contract" title="A transaction in which a spender and receiver place funds in a 2-of-2 (or other m-of-n) multisig output so that neither can spend the funds until they're both satisfied with some external outcome." id="term-escrow-contract" class="term">escrow
contract</a>. Charlie spends his satoshis
to an output which can only be spent if two of the three people sign the
input. Now Charlie can pay Bob if everything is ok, Bob can refund
Charlie’s money if there’s a problem, or Alice can arbitrate and decide
who should get the satoshis if there’s a dispute.</p>

  <p>To create a multiple-signature (<a href="/en/glossary/multisig" title="A pubkey script that provides *n* number of pubkeys and requires the corresponding signature script provide *m* minimum number signatures corresponding to the provided pubkeys." id="term-multisig" class="term">multisig</a>)
output, they each give the others a public key. Then Bob creates the
following <a href="/en/glossary/p2sh-multisig" title="A P2SH output where the redeem script uses one of the multisig opcodes.  Up until Bitcoin Core 0.10.0, P2SH multisig scripts were standard transactions, but most other P2SH scripts were not." id="term-p2sh-multisig" class="term">P2SH multisig</a> redeem script:</p>

  <div class="highlighter-rouge"><pre><code>OP_2 [A's pubkey] [B's pubkey] [C's pubkey] OP_3 OP_CHECKMULTISIG
</code></pre>
  </div>

  <p>(Opcodes to push the public keys onto the stack are not shown.)</p>

  <p><code class="highlighter-rouge">OP_2</code> and <code class="highlighter-rouge">OP_3</code> push the actual numbers 2 and 3 onto the
stack. <code class="highlighter-rouge">OP_2</code>
specifies that 2 signatures are required to sign; <code class="highlighter-rouge">OP_3</code> specifies that
3 public keys (unhashed) are being provided. This is a 2-of-3 multisig
pubkey script, more generically called a m-of-n pubkey script (where <em>m</em> is the
<em>minimum</em> matching signatures required and <em>n</em> in the <em>number</em> of public
keys provided).</p>

  <p>Bob gives the redeem script to Charlie, who checks to make sure his
public key and Alice’s public key are included. Then he hashes the
redeem script to create a P2SH redeem script and pays the satoshis to it. Bob
sees the payment get added to the block chain and ships the merchandise.</p>

  <p>Unfortunately, the merchandise gets slightly damaged in transit. Charlie
wants a full refund, but Bob thinks a 10% refund is sufficient. They
turn to Alice to resolve the issue. Alice asks for photo evidence from
Charlie along with a copy of the redeem script Bob created and
Charlie checked.</p>

  <p>After looking at the evidence, Alice thinks a 40% refund is sufficient,
so she creates and signs a transaction with two outputs, one that spends 60%
of the satoshis to Bob’s public key and one that spends the remaining
40% to Charlie’s public key.</p>

  <p>In the signature script Alice puts her signature
and a copy of the unhashed serialized redeem script
that Bob created.  She gives a copy of the incomplete transaction to
both Bob and Charlie.  Either one of them can complete it by adding
his signature to create the following signature script:</p>

  <div class="highlighter-rouge"><pre><code>OP_0 [A's signature] [B's or C's signature] [serialized redeem script]
</code></pre>
  </div>

  <p>(Opcodes to push the signatures and redeem script onto the stack are
not shown. <code class="highlighter-rouge">OP_0</code> is a workaround for an off-by-one error in the original
implementation which must be preserved for compatibility.  Note that
the signature script must provide signatures in the same order as the
corresponding public keys appear in the redeem script.  See the description in
<a href="/en/developer-reference#term-op-checkmultisig" title="Opcode which returns true if one or more provided signatures (m) sign the correct parts of a transaction and match one or more provided public keys (n)"><code class="highlighter-rouge">OP_CHECKMULTISIG</code></a> for details.)</p>

  <p>When the transaction is broadcast to the network, each peer checks the
signature script against the P2SH output Charlie previously paid,
ensuring that the redeem script matches the redeem script hash previously
provided. Then the redeem script is evaluated, with the two signatures
being used as input<!--noref--> data. Assuming the redeem script
validates, the two transaction outputs show up in Bob’s and Charlie’s
wallets as spendable balances.</p>

  <p>However, if Alice created and signed a transaction neither of them would
agree to, such as spending all the satoshis to herself, Bob and Charlie
can find a new arbitrator and sign a transaction spending the satoshis
to another 2-of-3 multisig redeem script hash, this one including a public
key from that second arbitrator. This means that Bob and Charlie never
need to worry about their arbitrator stealing their money.</p>

  <p><strong>Resource:</strong> <a href="https://www.bitrated.com/">BitRated</a> provides a multisig arbitration
service interface using HTML/JavaScript on a GNU AGPL-licensed website.</p>

  <h3 id="micropayment-channel">Micropayment Channel</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_contracts.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_contracts.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_contracts.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_contracts.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <!-- SOMEDAY: try to rewrite using a more likely real-world example without
making the text or illustration more complicated -->

  <p>Alice also works part-time moderating forum posts for Bob. Every time
someone posts to Bob’s busy forum, Alice skims the post to make sure it
isn’t offensive or spam. Alas, Bob often forgets to pay her, so Alice
demands to be paid immediately after each post she approves or rejects.
Bob says he can’t do that because hundreds of small payments will cost
him thousands of satoshis in transaction fees, so Alice suggests they use a
<a href="/en/developer-guide#term-micropayment-channel" id="term-micropayment-channel" class="term">micropayment channel</a>.</p>

  <p>Bob asks Alice for her public key and then creates two transactions.
The first transaction pays 100 millibitcoins to a P2SH output whose
2-of-2 multisig redeem script requires signatures from both Alice and Bob.
This is the bond transaction.
Broadcasting this transaction would let Alice hold the millibitcoins
hostage, so Bob keeps this transaction private for now and creates a
second transaction.</p>

  <p>The second transaction spends all of the first transaction’s millibitcoins
(minus a transaction fee) back to Bob after a 24 hour delay enforced
by locktime. This is the refund transaction. Bob can’t sign the refund transaction by himself, so he gives
it to Alice to sign, as shown in the
illustration below.</p>

  <p><img src="/img/dev/en-micropayment-channel.svg" alt="Micropayment Channel Example" /></p>

  <p>Alice checks that the refund transaction’s locktime is 24 hours in the
future, signs it, and gives a copy of it back to Bob. She then asks Bob
for the bond transaction and checks that the refund transaction spends
the output of the bond transaction. She can now broadcast the bond
transaction to the network to ensure Bob has to wait for the time lock
to expire before further spending his millibitcoins. Bob hasn’t actually
spent anything so far, except possibly a small transaction fee, and
he’ll be able to broadcast the refund transaction in 24 hours for a
full refund.</p>

  <p>Now, when Alice does some work worth 1 millibitcoin, she asks Bob to create
and sign a new version of the refund transaction.  Version two of the
transaction spends 1 millibitcoin to Alice and the other 99 back to Bob; it does
not have a locktime, so Alice can sign it and spend it whenever she
wants.  (But she doesn’t do that immediately.)</p>

  <p>Alice and Bob repeat these work-and-pay steps until Alice finishes for
the day, or until the time lock is about to expire.  Alice signs the
final version of the refund transaction and broadcasts it, paying
herself and refunding any remaining balance to Bob.  The next day, when
Alice starts work, they create a new micropayment channel.</p>

  <p>If Alice fails to broadcast a version of the refund transaction before
its time lock expires, Bob can broadcast the first version and receive a
full refund. This is one reason micropayment channels are best suited to
small payments—if Alice’s Internet service goes out for a few hours
near the time lock expiry, she could be cheated out of her payment.</p>

  <p>Transaction malleability, discussed above in the Transactions section,
is another reason to limit the value of micropayment channels.
If someone uses transaction malleability to break the link between the
two transactions, Alice could hold Bob’s 100 millibitcoins hostage even if she
hadn’t done any work.</p>

  <p>For larger payments, Bitcoin transaction fees are very low as a
percentage of the total transaction value, so it makes more sense to
protect payments with immediately-broadcast separate transactions.</p>

  <p><strong>Resource:</strong> The <a href="http://bitcoinj.github.io">bitcoinj</a> Java library
provides a complete set of micropayment functions, an example
implementation, and <a href="https://bitcoinj.github.io/working-with-micropayments">a
tutorial</a>
all under an Apache license.</p>

  <h3 id="coinjoin">CoinJoin</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_contracts.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_contracts.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_contracts.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_contracts.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Alice is concerned about her privacy.  She knows every transaction gets
added to the public block chain, so when Bob and Charlie pay her, they
can each easily track those satoshis to learn what Bitcoin
addresses she pays, how much she pays them, and possibly how many
satoshis she has left.</p>

  <p>Alice isn’t a criminal, she just wants plausible deniability about
where she has spent her satoshis and how many she has left, so she
starts up the Tor anonymity service on her computer and logs into an
IRC chatroom as “AnonGirl.”</p>

  <p>Also in the chatroom are “Nemo” and “Neminem.”  They collectively
agree to transfer satoshis between each other so no one besides them
can reliably determine who controls which satoshis.  But they’re faced
with a dilemma: who transfers their satoshis to one of the other two
pseudonymous persons first? The CoinJoin-style contract, shown in the
illustration below, makes this decision easy: they create a single
transaction which does all of the spending simultaneously, ensuring none
of them can steal the others’ satoshis.</p>

  <p><img src="/img/dev/en-coinjoin.svg" alt="Example CoinJoin Transaction" /></p>

  <p>Each contributor looks through their collection of Unspent Transaction
Outputs (UTXOs) for 100 millibitcoins they can spend. They then each generate
a brand new public key and give UTXO details and pubkey hashes to the
facilitator.  In this case, the facilitator is AnonGirl; she creates
a transaction spending each of the UTXOs to three equally-sized outputs.
One output goes to each of the contributors’ pubkey hashes.</p>

  <p>AnonGirl then signs her inputs using <code class="highlighter-rouge">SIGHASH_ALL</code> to ensure nobody can
change the input or output details.  She gives the partially-signed
transaction to Nemo who signs his inputs the same way and passes it
to Neminem, who also signs it the same way.  Neminem then broadcasts
the transaction to the peer-to-peer network, mixing all of the millibitcoins in
a single transaction.</p>

  <p>As you can see in the illustration, there’s no way for anyone besides
AnonGirl, Nemo, and Neminem to confidently determine who received
which output, so they can each spend their output with plausible
deniability.</p>

  <p>Now when Bob or Charlie try to track Alice’s transactions through the
block chain, they’ll also see transactions made by Nemo and
Neminem.  If Alice does a few more CoinJoins, Bob and Charlie might
have to guess which transactions made by dozens or hundreds of people
were actually made by Alice.</p>

  <p>The complete history of Alice’s satoshis is still in the block chain,
so a determined investigator could talk to the people AnonGirl
CoinJoined with to find out the ultimate origin of her satoshis and
possibly reveal AnonGirl as Alice. But against anyone casually browsing
block chain history, Alice gains plausible deniability.</p>

  <p>The CoinJoin technique described above costs the participants a small
amount of satoshis to pay the transaction fee.  An alternative
technique, purchaser CoinJoin, can actually save them satoshis and
improve their privacy at the same time.</p>

  <p>AnonGirl waits in the IRC chatroom until she wants to make a purchase.
She announces her intention to spend satoshis and waits until someone
else wants to make a purchase, likely from a different merchant. Then
they combine their inputs the same way as before but set the outputs
to the separate merchant addresses so nobody will be able to figure
out solely from block chain history which one of them bought what from
the merchants.</p>

  <p>Since they would’ve had to pay a transaction fee to make their purchases
anyway, AnonGirl and her co-spenders don’t pay anything extra—but
because they reduced overhead by combining multiple transactions, saving
bytes, they may be able to pay a smaller aggregate transaction fee,
saving each one of them a tiny amount of satoshis.</p>

  <p><strong>Resource:</strong> An alpha-quality (as of this writing) implementation of decentralized
CoinJoin is <a href="http://coinmux.com/">CoinMux</a>, available under the Apache
license.</p>

  <h2 id="wallets">Wallets</h2>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>A Bitcoin wallet can refer to either a wallet program or a wallet file.
Wallet programs create public keys to receive satoshis and use the
corresponding private keys to spend those satoshis. Wallet files
store private keys and (optionally) other information related to
transactions for the wallet program.</p>

  <p>Wallet programs and wallet files are addressed below in separate
subsections, and this document attempts to always make it clear whether
we’re talking about wallet programs or wallet files.</p>

  <h3 id="wallet-programs">Wallet Programs</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Permitting receiving and spending of satoshis is the only essential
feature of wallet software—but a particular wallet program doesn’t
need to do both things.  Two wallet programs can work together, one
program distributing public keys in order to receive satoshis and
another program signing transactions spending those satoshis.</p>

  <p>Wallet programs also need to interact with the peer-to-peer network to
get information from the block chain and to broadcast new transactions.
However, the programs which distribute public keys or sign transactions
don’t need to interact with the peer-to-peer network themselves.</p>

  <p>This leaves us with three necessary, but separable, parts of a wallet
system: a public key distribution program, a signing program, and a
networked program.  In the subsections below, we will describe common
combinations of these parts.</p>

  <p>Note: we speak about distributing public keys generically. In many
cases, P2PKH or P2SH hashes will be distributed instead of public keys,
with the actual public keys only being distributed when the outputs
they control are spent.</p>

  <h4 id="full-service-wallets">Full-Service Wallets</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The simplest wallet is a program which performs all three functions: it
generates private keys, derives the corresponding public keys, helps
distribute those public keys as necessary, monitors for outputs spent to
those public keys, creates and signs transactions spending those
outputs, and broadcasts the signed transactions.</p>

  <p><img src="/img/dev/en-wallets-full-service.svg" alt="Full-Service Wallets" /></p>

  <p>As of this writing, almost all popular wallets can be used as
full-service wallets.</p>

  <p>The main advantage of full-service wallets is that they are easy to use.
A single program does everything the user needs to receive and spend
satoshis.</p>

  <p>The main disadvantage of full-service wallets is that they store the
private keys on a device connected to the Internet.  The compromise of
such devices is a common occurrence, and an Internet connection makes it
easy to transmit private keys from a compromised device to an attacker.</p>

  <p>To help protect against theft, many wallet programs offer users the
option of encrypting the wallet files which contain the private keys.
This protects the private keys when they aren’t being used, but it
cannot protect against an attack designed to capture the encryption
key or to read the decrypted keys from memory.</p>

  <h4 id="signing-only-wallets">Signing-Only Wallets</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>To increase security, private keys can be generated and stored by a
separate wallet program operating in a more secure environment. These
signing-only wallets work in conjunction with a networked wallet which
interacts with the peer-to-peer network.</p>

  <p>Signing-only wallets programs typically use deterministic key creation
(described in a later subsection) to create parent private and public
keys which can create child private and public keys.</p>

  <p><img src="/img/dev/en-wallets-signing-only.svg" alt="Signing-Only Wallets" /></p>

  <p>When first run, the signing-only wallet creates a parent private key and
transfers the corresponding parent public key to the networked wallet.</p>

  <p>The networked wallet uses the parent public key to derive child public
keys, optionally helps distribute them, monitors for outputs spent to
those public keys, creates unsigned transactions spending those outputs,
and transfers the unsigned transactions to the signing-only wallet.</p>

  <p>Often, users are given a chance to review the unsigned transactions’ details
(particularly the output details) using the signing-only wallet.</p>

  <p>After the optional review step, the signing-only wallet uses the parent
private key to derive the appropriate child private keys and signs the
transactions, giving the signed transactions back to the networked wallet.</p>

  <p>The networked wallet then broadcasts the signed transactions to the
peer-to-peer network.</p>

  <p>The following subsections describe the two most common variants of
signing-only wallets: offline wallets and hardware wallets.</p>

  <h5 id="offline-wallets">Offline Wallets</h5>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Several full-service wallets programs will also operate as two separate
wallets: one program instance acting as a signing-only wallet (often called an
“offline wallet”) and the other program instance acting as the networked
wallet (often called an “online wallet” or “watching-only wallet”).</p>

  <p>The offline wallet is so named because it is intended to be run on a
device which does not connect to any network, greatly reducing the
number of attack vectors. If this is the case, it is usually up to the
user to handle all data transfer using removable media such as USB
drives.  The user’s workflow is something like:</p>

  <ol>
    <li>
      <p>(Offline) Disable all network connections on a device and install the wallet
software. Start the wallet software in offline mode to create the
parent private and public keys.  Copy the parent public key to
removable media.</p>
    </li>
    <li>
      <p>(Online) Install the wallet software on another device, this one
connected to the Internet, and import the parent public key from the
removable media. As you would with a full-service wallet, distribute
public keys to receive payment. When ready to spend satoshis, fill in
the output details and save the unsigned transaction generated by the
wallet to removable media.</p>
    </li>
    <li>
      <p>(Offline) Open the unsigned transaction in the offline instance,
review the output details to make sure they spend the correct
amount to the correct address. This prevents malware on the online
wallet from tricking the user into signing a transaction which pays
an attacker. After review, sign the transaction and save it to
removable media.</p>
    </li>
    <li>
      <p>(Online) Open the signed transaction in the online instance so it can
broadcast it to the peer-to-peer network.</p>
    </li>
  </ol>

  <p>The primary advantage of offline wallets is their possibility for
greatly improved security over full-service wallets.  As long as the
offline wallet is not compromised (or flawed) and the user reviews all outgoing
transactions before signing, the user’s satoshis are safe even if the
online wallet is compromised.</p>

  <p>The primary disadvantage of offline wallets is hassle. For maximum
security, they require the user dedicate a device to only offline tasks.
The offline device must be booted up whenever funds are to be spent, and
the user must physically copy data from the online device to the offline
device and back.</p>

  <h5 id="hardware-wallets">Hardware Wallets</h5>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Hardware wallets are devices dedicated to running a signing-only wallet.
Their dedication lets them eliminate many of the vulnerabilities
present in operating systems designed for general use, allowing them
to safely communicate directly with other devices so users don’t need to
transfer data manually.  The user’s workflow is something like:</p>

  <ol>
    <li>
      <p>(Hardware) Create parent private and public keys. Connect hardware
wallet to a networked device so it can get the parent public key.</p>
    </li>
    <li>
      <p>(Networked) As you would with a full-service wallet, distribute
public keys to receive payment. When ready to spend satoshis, fill in
the transaction details, connect the hardware wallet, and click
Spend.  The networked wallet will automatically send the transaction
details to the hardware wallet.</p>
    </li>
    <li>
      <p>(Hardware) Review the transaction details on the hardware wallet’s
screen. Some hardware wallets may prompt for a passphrase or PIN
number. The hardware wallet signs the transaction and uploads it to
the networked wallet.</p>
    </li>
    <li>
      <p>(Networked) The networked wallet receives the signed transaction from
the hardware wallet and broadcasts it to the network.</p>
    </li>
  </ol>

  <p>The primary advantage of hardware wallets is their possibility for
greatly improved security over full-service wallets with much less
hassle than offline wallets.</p>

  <p>The primary disadvantage of hardware wallets is their hassle. Even
though the hassle is less than that of offline wallets, the user must
still purchase a hardware wallet device and carry it with them whenever
they need to make a transaction using the signing-only wallet.</p>

  <p>An additional (hopefully temporary) disadvantage is that, as of this
writing, very few popular wallet programs support hardware
wallets—although almost all popular wallet programs have announced
their intention to support at least one model of hardware wallet.</p>

  <h4 id="distributing-only-wallets">Distributing-Only Wallets</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Wallet programs which run in difficult-to-secure environments, such as
webservers, can be designed to distribute public keys (including P2PKH
or P2SH addresses) and nothing more.  There are two common ways to
design these minimalist wallets:</p>

  <p><img src="/img/dev/en-wallets-distributing-only.svg" alt="Distributing-Only Wallets" /></p>

  <ul>
    <li>
      <p>Pre-populate a database with a number of public keys or addresses, and
then distribute on request a pubkey script or address using one of
the database entries. To <a href="/en/developer-guide#avoiding-key-reuse">avoid key reuse</a>, webservers should keep track
of used keys and never run out of public keys. This can be made easier
by using parent public keys as suggested in the next method.</p>
    </li>
    <li>
      <p>Use a parent public key to create child public keys. To avoid key
reuse, a method must be used to ensure the same public key isn’t
distributed twice. This can be a database entry for each key
distributed or an incrementing pointer to the key
index number.</p>
    </li>
  </ul>

  <p>Neither method adds a significant amount of overhead, especially if a
database is used anyway to associate each incoming payment with a
separate public key for payment tracking. See the <a href="/en/developer-guide#payment-processing">Payment
Processing</a> section for details.</p>

  <h3 id="wallet-files">Wallet Files</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Bitcoin wallets at their core are a collection of private keys. These
collections are stored digitally in a file, or can even be physically
stored on pieces of paper.</p>

  <h4 id="private-key-formats">Private Key Formats</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Private keys are what are used to unlock satoshis from a particular address. In Bitcoin, a private key in standard format is simply a 256-bit number, between the values:</p>

  <p>0x01 and 0xFFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFE BAAE DCE6 AF48 A03B BFD2 5E8C D036 4140, representing nearly the entire range of 2<sup>256</sup>-1 values. The range is governed by the secp256k1 ECDSA encryption standard used by Bitcoin.</p>

  <h5 id="wallet-import-format-wif">Wallet Import Format (WIF)</h5>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>In order to make copying of private keys less prone to error, <a href="/en/glossary/wallet-import-format" title="A data interchange format designed to allow exporting and importing a single private key with a flag indicating whether or not it uses a compressed public key." id="term-wallet-import-format" class="term">Wallet Import Format</a> may be utilized. WIF uses base58Check encoding on an private key, greatly decreasing the chance of copying error, much like standard Bitcoin addresses.</p>

  <ol>
    <li>
      <p>Take a private key.</p>
    </li>
    <li>
      <p>Add a 0x80 byte in front of it for mainnet addresses or 0xef for testnet addresses.</p>
    </li>
    <li>
      <p>Append a 0x01 byte after it if it should be used with compressed
public keys (described in a later subsection). Nothing is appended if
it is used with uncompressed public keys.</p>
    </li>
    <li>
      <p>Perform a SHA-256 hash on the extended key.<!--noref--></p>
    </li>
    <li>
      <p>Perform a SHA-256 hash on result of SHA-256 hash.</p>
    </li>
    <li>
      <p>Take the first four bytes of the second SHA-256 hash; this is the checksum.</p>
    </li>
    <li>
      <p>Add the four checksum bytes from point 5 at the end of the extended key<!--noref--> from point 2.</p>
    </li>
    <li>
      <p>Convert the result from a byte string into a Base58 string using Base58Check encoding.</p>
    </li>
  </ol>

  <p>The process is easily reversible, using the Base58 decoding function, and removing the padding.</p>

  <h5 id="mini-private-key-format">Mini Private Key Format</h5>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Mini private key format is a method for encoding a private key in under 30 characters, enabling keys to be embedded in a small physical space, such as physical bitcoin tokens, and more damage-resistant QR codes.</p>

  <ol>
    <li>
      <p>The first character of mini keys is ‘S’.</p>
    </li>
    <li>
      <p>In order to determine if a mini private key is well-formatted, a question mark is added to the private key.</p>
    </li>
    <li>
      <p>The SHA256 hash is calculated. If the first byte produced is a `00’, it is well-formatted. This key restriction acts as a typo-checking mechanism. A user brute forces the process using random numbers until a well-formatted mini private key is produced.</p>
    </li>
    <li>
      <p>In order to derive the full private key, the user simply takes a single SHA256 hash of the original mini private key. This process is one-way: it is intractable to compute the mini private key format from the derived key.</p>
    </li>
  </ol>

  <p>Many implementations disallow the character ‘1’ in the mini private key due to its visual similarity to ‘l’.</p>

  <p><strong>Resource:</strong> A common tool to create and redeem these keys is the <a href="https://github.com/casascius/Bitcoin-Address-Utility">Casascius Bitcoin Address Utility</a>.</p>

  <h4 id="public-key-formats">Public Key Formats</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Bitcoin ECDSA public keys represent a point on a particular Elliptic
Curve (EC) defined in secp256k1. In their traditional uncompressed form,
public keys contain an identification byte, a 32-byte X coordinate, and
a 32-byte Y coordinate. The extremely simplified illustration below
shows such a point on the elliptic curve used by Bitcoin,
y<sup>2</sup> = x<sup>3</sup> + 7, over a field of
contiguous numbers.</p>

  <p><img src="/img/dev/en-ecdsa-compressed-public-key.svg" alt="Point On ECDSA Curve" /></p>

  <p>(Secp256k1 actually modulos coordinates by a large prime, which produces a
field of non-contiguous integers and a significantly less clear plot,
although the principles are the same.)</p>

  <p>An almost 50% reduction in public key size can be realized without
changing any fundamentals by dropping the Y coordinate. This is possible
because only two points along the curve share any particular X
coordinate, so the 32-byte Y coordinate can be replaced with a single
bit indicating whether the point is on what appears in the illustration
as the “top” side or the “bottom” side.</p>

  <p>No data is lost by creating these compressed public keys—only a small
amount of CPU is necessary to reconstruct the Y coordinate and access
the uncompressed public key. Both uncompressed and compressed public
keys are described in official secp256k1 documentation and supported by
default in the widely-used OpenSSL library.</p>

  <p>Because they’re easy to use, and because they reduce almost by half
the block chain space used to store public keys for every spent output,
compressed public keys are the default in Bitcoin Core and are the
recommended default for all Bitcoin software.</p>

  <p>However, Bitcoin Core prior to 0.6 used uncompressed keys.  This creates
a few complications, as the hashed form of an uncompressed key is
different than the hashed form of a compressed key, so the same key
works with two different P2PKH addresses.   This also means that the key
must be submitted in the correct format in the signature script so it
matches the hash in the previous output’s pubkey script.</p>

  <p>For this reason, Bitcoin Core uses several different identifier bytes to
help programs identify how keys should be used:</p>

  <ul>
    <li>
      <p>Private keys meant to be used with compressed public keys have 0x01
appended to them before being Base-58 encoded. (See the private key
encoding section above.)</p>
    </li>
    <li>
      <p>Uncompressed public keys start with 0x04; compressed public keys begin
with 0x03 or 0x02 depending on whether they’re greater or less than
the midpoint of the curve.  These prefix bytes are all used in
official secp256k1 documentation.</p>
    </li>
  </ul>

  <h4 id="hierarchical-deterministic-key-creation">Hierarchical Deterministic Key Creation</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <!-- 
For consistent word ordering:
[normal|hardened|] [master|parent|child|grandchild] [extended|non-extended|] [private|public|chain] [key|code]
-->

  <p>The hierarchical deterministic key creation and transfer protocol (<a href="/en/glossary/hd-protocol" title="The Hierarchical Deterministic (HD) key creation and transfer protocol (BIP32), which allows creating child keys from parent keys in a hierarchy. Wallets using the HD protocol are called HD wallets." id="term-hd-protocol" class="term">HD
protocol</a>) greatly simplifies wallet
backups, eliminates the need for repeated communication between multiple
programs using the same wallet, permits creation of child accounts which
can operate independently, gives each parent account the ability to
monitor or control its children even if the child account is
compromised, and divides each account into full-access and
restricted-access parts so untrusted users or programs can be allowed to
receive or monitor payments without being able to spend them.</p>

  <p>The HD protocol takes advantage of the ECDSA public key creation
function, <a href="/en/developer-guide#term-point-function" title="The ECDSA function used to create a public key from a private key" id="term-point-function" class="term"><code class="highlighter-rouge">point()</code></a>,
which takes a large integer (the private key) and turns it into a graph
point (the public key):</p>

  <div class="highlighter-rouge"><pre><code>point(private_key) == public_key
</code></pre>
  </div>

  <p>Because of the way <code class="highlighter-rouge">point()</code> works, it’s possible to create a <a href="/en/glossary/child-key" title="In HD wallets, a key derived from a parent key.  The key can be either a private key or a public key, and the key derivation may also require a chain code." id="term-child-public-key" class="term">child
public key</a> by combining an
existing <a href="/en/glossary/parent-key" title="In HD wallets, a key used to derive child keys.  The key can be either a private key or a public key, and the key derivation may also require a chain code." id="term-parent-public-key" class="term">(parent) public key</a> with another public key created from any
integer (<em>i</em>) value. This child public key is the same public key which
would be created by the <code class="highlighter-rouge">point()</code> function if you added the <em>i</em> value to
the original (parent) private key and then found the remainder of that
sum divided by a global constant used by all Bitcoin software (<em>p</em>):</p>

  <div class="highlighter-rouge"><pre><code>point( (parent_private_key + i) % p ) == parent_public_key + point(i)
</code></pre>
  </div>

  <p>This means that two or more independent programs which agree on a
sequence of integers can create a series of unique <a href="/en/glossary/child-key" title="In HD wallets, a key derived from a parent key.  The key can be either a private key or a public key, and the key derivation may also require a chain code." id="term-child-key" class="term">child key</a> pairs from
a single <a href="/en/glossary/parent-key" title="In HD wallets, a key used to derive child keys.  The key can be either a private key or a public key, and the key derivation may also require a chain code." id="term-parent-key" class="term">parent key</a> pair without any further communication.
Moreover, the program which distributes new public keys for receiving
payment can do so without any access to the private keys, allowing the
public key distribution program to run on a possibly-insecure platform such as
a public web server.</p>

  <p>Child public keys can also create their own child public keys
(grandchild public keys) by repeating the child key derivation
operations:</p>

  <div class="highlighter-rouge"><pre><code>point( (child_private_key + i) % p ) == child_public_key + point(i)
</code></pre>
  </div>

  <p>Whether creating child public keys or further-descended public keys, a
predictable sequence of integer values would be no better than using a
single public key for all transactions, as anyone who knew one child
public key could find all of the other child public keys created from
the same parent public key. Instead, a random seed can be used to
deterministically generate the sequence of integer values so that the
relationship between the child public keys is invisible to anyone
without that seed.</p>

  <p>The HD protocol uses a single root seed to create a hierarchy of
child, grandchild, and other descended keys with unlinkable
deterministically-generated integer values. Each child key also gets
a deterministically-generated seed from its parent, called a <a href="/en/glossary/chain-code" title="In HD wallets, 256 bits of entropy added to the public and private keys to help them generate secure child keys; the master chain code is usually derived from a seed along with the master private key" id="term-chain-code" class="term">chain
code</a>, so the compromising of one chain
code doesn’t necessarily compromise the integer sequence for the whole
hierarchy, allowing the <a href="/en/glossary/master-chain-code-and-private-key" title="In HD wallets, the master chain code and master private key are the two pieces of data derived from the root seed." id="term-master-chain-code" class="term">master chain
code</a> to continue being useful
even if, for example, a web-based public key distribution program
gets hacked.</p>

  <p><img src="/img/dev/en-hd-overview.svg" alt="Overview Of Hierarchical Deterministic Key Derivation" /></p>

  <p>As illustrated above, HD key derivation takes four inputs<!--noref-->:</p>

  <ul>
    <li>
      <p>The <em><a href="/en/glossary/parent-key" title="In HD wallets, a key used to derive child keys.  The key can be either a private key or a public key, and the key derivation may also require a chain code." id="term-parent-private-key" class="term">parent private key</a></em> and
<em>parent public key</em> are regular uncompressed 256-bit ECDSA keys.</p>
    </li>
    <li>
      <p>The <a href="/en/glossary/chain-code" title="In HD wallets, 256 bits of entropy added to the public and private keys to help them generate secure child keys; the master chain code is usually derived from a seed along with the master private key" id="term-parent-chain-code" class="term">parent chain code</a> is 256
bits of seemingly-random data.</p>
    </li>
    <li>
      <p>The <a href="/en/developer-guide#term-key-index" title="An index number used in the HD wallet formula to generate child keys from a parent key" id="term-key-index" class="term">index</a> number is a 32-bit integer specified by the program.</p>
    </li>
  </ul>

  <p>In the normal form shown in the above illustration, the parent chain
code, the parent public key, and the index number are fed into a one-way cryptographic hash
(<a href="https://en.wikipedia.org/wiki/HMAC">HMAC-SHA512</a>) to produce 512 bits of
deterministically-generated-but-seemingly-random data. The
seemingly-random 256 bits on the righthand side of the hash output are
used as a new child chain code. The seemingly-random 256 bits on the
lefthand side of the hash output are used as the integer value to be combined
with either the parent private key or parent public key to,
respectively, create either a child private key or child public key:</p>

  <div class="highlighter-rouge"><pre><code>child_private_key == (parent_private_key + lefthand_hash_output) % G
child_public_key == point( (parent_private_key + lefthand_hash_output) % G )
child_public_key == point(child_private_key) == parent_public_key + point(lefthand_hash_output)
</code></pre>
  </div>

  <p>Specifying different index numbers will create different unlinkable
child keys from the same parent keys.  Repeating the procedure for the
child keys using the child chain code will create unlinkable grandchild keys.</p>

  <p>Because creating child keys requires both a key and a chain code, the
key and chain code together are called the <a href="/en/glossary/extended-key" title="In the context of HD wallets, a public key or private key extended with the chain code to allow them to derive child keys." id="term-extended-key" class="term">extended
key</a>. An <a href="/en/glossary/extended-key" title="In the context of HD wallets, a public key or private key extended with the chain code to allow them to derive child keys." id="term-extended-private-key" class="term">extended private
key</a> and its corresponding
<a href="/en/glossary/extended-key" title="In the context of HD wallets, a public key or private key extended with the chain code to allow them to derive child keys." id="term-extended-public-key" class="term">extended public key</a> have the
same chain code. The (top-level parent) <a href="/en/glossary/master-chain-code-and-private-key" title="In HD wallets, the master chain code and master private key are the two pieces of data derived from the root seed." id="term-master-private-key" class="term">master private
key</a> and master chain
code are derived from random data,
as illustrated below.</p>

  <p><img src="/img/dev/en-hd-root-keys.svg" alt="Creating A Root Extended Key Pair" /></p>

  <p>A <a href="/en/glossary/hd-wallet-seed" title="A potentially-short value used as a seed to generate the master private key and master chain code for an HD wallet." id="term-root-seed" class="term">root seed</a> is created from either 128
bits, 256 bits, or 512 bits of random data. This root seed of as little
as 128 bits is the the only data the user needs to backup in order to
derive every key created by a particular wallet program using
particular settings.</p>

  <p><img src="/img/icons/icon_warning.svg" alt="Warning icon" />
 <strong>Warning:</strong> As of this writing, HD wallet programs are not expected to
be fully compatible, so users must only use the same HD wallet program
with the same HD-related settings for a particular root seed.</p>

  <p>The root seed is hashed to create 512 bits of seemingly-random data,
from which the master private key and master chain code are created
(together, the master extended private key). The master public key is
derived from the master private key using <code class="highlighter-rouge">point()</code>, which, together
with the master chain code, is the master extended public
key. The master extended keys are functionally equivalent to other
extended keys; it is only their location at the top of the hierarchy
which makes them special.</p>

  <h5 id="hardened-keys">Hardened Keys</h5>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Hardened extended keys fix a potential problem with normal extended keys.
If an attacker gets a normal parent
chain code and parent public key, he can brute-force all chain
codes deriving from it. If the attacker also obtains a child, grandchild, or
further-descended private key, he can use the chain code to generate all
of the extended private keys descending from that private key, as
shown in the grandchild and great-grandchild generations of the illustration below.</p>

  <p><img src="/img/dev/en-hd-cross-generational-key-compromise.svg" alt="Cross-Generational Key Compromise" /></p>

  <p>Perhaps worse, the attacker can reverse the normal child private key
derivation formula and subtract a parent chain code from a child private
key to recover the parent private key, as shown in the child and
parent generations of the illustration above.  This means an attacker
who acquires an extended public key and any private key descended from
it can recover that public key’s private key and all keys descended from
it.</p>

  <p>For this reason, the chain code part of an extended public key should be
better secured than standard public keys and users should be advised
against exporting even non-extended private keys to
possibly-untrustworthy environments.</p>

  <p>This can be fixed, with some tradeoffs, by replacing the the normal
key derivation formula with a hardened key derivation formula.</p>

  <p>The normal key derivation formula, described in the section above, combines
together the index number, the parent chain code, and the parent public key to create the
child chain code and the integer value which is combined with the parent
private key to create the child private key.</p>

  <p><img src="/img/dev/en-hd-private-parent-to-private-child.svg" alt="Creating Child Public Keys From An Extended Private Key" /></p>

  <p>The hardened formula, illustrated above, combines together the index
number, the parent chain code, and the parent private key to create
the data used to generate the child chain code and child private key.
This formula makes it impossible to create child public keys without
knowing the parent private key. In other words, parent extended public
keys can’t create hardened child public keys.</p>

  <p>Because of that, a <a href="/en/glossary/hardened-extended-key" title="A variation on HD wallet extended keys where only the hardened extended private key can derive child keys. This prevents compromise of the chain code plus any private key from putting the whole wallet at risk." id="term-hardened-extended-private-key" class="term">hardened extended private
key</a> is much less
useful than a normal extended private key—however, 
hardened extended private keys create a firewall through which
multi-level key derivation compromises cannot happen. Because hardened
child extended public keys cannot generate grandchild chain codes on
their own, the compromise of a parent extended public key cannot be
combined with the compromise of a grandchild private key to create
great-grandchild extended private keys.</p>

  <p>The HD protocol uses different index numbers to indicate
whether a normal or hardened key should be generated. Index numbers from
0x00 to 0x7fffffff (0 to 2<sup>31</sup>-1) will generate a normal key; index
numbers from 0x80000000 to 0xffffffff will generate a hardened key. To
make descriptions easy, many developers use the <a href="https://en.wikipedia.org/wiki/Prime_%28symbol%29">prime symbol</a> to indicate
hardened keys, so the first normal key (0x00) is 0 and the first hardened
key (0x80000000) is 0´.</p>

  <p>(Bitcoin developers typically use the ASCII apostrophe rather than
the unicode prime symbol, a convention we will henceforth follow.)</p>

  <p>This compact description is further combined with slashes prefixed by
<em>m</em> or <em>M</em> to indicate hierarchy and key type, with <em>m</em> being a private
key and <em>M</em> being a public key. For example, m/0’/0/122’ refers to the
123rd hardened private child (by index number) of the first normal child
(by index) of the first hardened child (by index) of the master private
key. The following hierarchy illustrates prime notation and hardened key
firewalls.</p>

  <p><img src="/img/dev/en-hd-tree.svg" alt="Example HD Wallet Tree Using Prime Notation" /></p>

  <p>Wallets following the BIP32 HD protocol only create hardened children of
the master private key (<em>m</em>) to prevent a compromised child key from
compromising the master key. As there are no normal children for the
master keys, the master public key is not used in HD wallets. All other
keys can have normal children, so the corresponding extended public keys
may be used instead.</p>

  <p>The HD protocol also describes a serialization format for extended
public keys and extended private keys.  For details, please see the
<a href="/en/developer-reference#wallets">wallet section in the developer reference</a> or BIP32
for the full HD protocol specification.</p>

  <h5 id="storing-root-seeds">Storing Root Seeds</h5>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Root seeds in the HD protocol are 128, 256, or 512 bits of random data
which must be backed up precisely. To make it more convenient to use
non-digital backup methods, such as memorization or hand-copying, BIP39
defines a method for creating a 512-bit root seed from a pseudo-sentence
(mnemonic) of common natural-language words which was itself created
from 128 to 256 bits of entropy and optionally protected by a password.</p>

  <p>The number of words generated correlates to the amount of entropy used:</p>

  <table>
    <thead>
      <tr>
        <th>Entropy Bits</th>
        <th>Words</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>128</td>
        <td>12</td>
      </tr>
      <tr>
        <td>160</td>
        <td>15</td>
      </tr>
      <tr>
        <td>192</td>
        <td>18</td>
      </tr>
      <tr>
        <td>224</td>
        <td>21</td>
      </tr>
      <tr>
        <td>256</td>
        <td>24</td>
      </tr>
    </tbody>
  </table>

  <p>The passphrase can be of any length.  It is simply appended to the mnemonic
pseudo-sentence, and then both the mnemonic and password are hashed
2,048 times using HMAC-SHA512, resulting in a seemingly-random 512-bit seed.  Because any
input<!--noref--> to the hash function creates a seemingly-random 512-bit seed,
there is no fundamental way to prove the user entered the correct
password, possibly allowing the user to protect a seed even when under
duress.</p>

  <p>For implementation details, please see BIP39.</p>

  <h4 id="loose-key-wallets">Loose-Key Wallets</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_wallets.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_wallets.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_wallets.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_wallets.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Loose-Key wallets, also called “Just a Bunch Of Keys (JBOK)”, are a deprecated form of wallet that originated from the Bitcoin Core client wallet. The Bitcoin Core client wallet would create 100 private key/public key pairs automatically via a Pseudo-Random-Number Generator (PRNG) for later use.</p>

  <p>These unused private keys are stored in a virtual “key pool”, with new
keys being generated whenever a previously-generated key was used,
ensuring the pool maintained 100 unused keys. (If the wallet is
encrypted, new keys are only generated while the wallet is unlocked.)</p>

  <p>This created considerable difficulty<!--noref--> in backing up one’s keys, considering backups have to be run manually to save the newly-generated private keys. If a new key pair set is generated, used, and then lost prior to a backup, the stored satoshis are likely lost forever. Many older-style mobile wallets followed a similar format, but only generated a new private key upon user demand.</p>

  <p>This wallet type is being actively phased out and discouraged from being used due to the backup hassle.</p>

  <h2 id="payment-processing">Payment Processing</h2>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Payment processing encompasses the steps spenders and receivers perform
to make and accept payments in exchange for products or services. The
basic steps have not changed since the dawn of commerce, but the
technology has. This section will explain how receivers and spenders
can, respectively, request and make payments using Bitcoin—and how
they can deal with complications such as refunds and recurrent
rebilling.</p>

  <p><img src="/img/dev/en-payment-processing.svg" alt="Bitcoin Payment Processing" /></p>

  <p>The figure above illustrates payment processing using Bitcoin from a
receiver’s perspective, starting with a new order. The following
subsections will each address<!--noref--> the three common steps and the three
occasional or optional steps.</p>

  <p>It is worth mentioning that each of these steps can be outsourced by
using third party APIs and services.</p>

  <h3 id="pricing-orders">Pricing Orders</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Because of exchange rate variability between satoshis and national
currencies (<a href="/en/developer-guide#term-fiat" title="National currencies such as the dollar or euro" id="term-fiat" class="term">fiat</a>), many Bitcoin orders are priced in fiat but paid
in satoshis, necessitating a price conversion.</p>

  <p>Exchange rate data is widely available through HTTP-based APIs provided
by currency exchanges. Several organizations also aggregate data from
multiple exchanges to create index prices, which are also available using
HTTP-based APIs.</p>

  <p>Any applications which automatically calculate order totals using exchange
rate data must take steps to ensure the price quoted reflects the
current general market value of satoshis, or the applications could
accept too few satoshis for the product or service being sold.
Alternatively, they could ask for too many satoshis, driving away potential
spenders.</p>

  <p>To minimize problems, your applications may want to collect data from at
least two separate sources and compare them to see how much they differ.
If the difference is substantial, your applications can enter a safe mode
until a human is able to evaluate the situation.</p>

  <p>You may also want to program your applications to enter a safe mode if
exchange rates are rapidly increasing or decreasing, indicating a
possible problem in the Bitcoin market which could make it difficult to
spend any satoshis received today.</p>

  <p>Exchange rates lie outside the control of Bitcoin and related
technologies, so there are no new or planned technologies which
will make it significantly easier for your program to correctly convert
order totals from fiat into satoshis.</p>

  <p>Because the exchange rate fluctuates over time, order totals pegged to
fiat must expire to prevent spenders from delaying payment in the hope
that satoshis will drop in price. Most widely-used payment processing
systems currently expire their invoices after 10 to 20 minutes.</p>

  <p>Shorter expiration periods increase the chance the invoice will expire
before payment is received, possibly necessitating manual intervention
to request an additional payment or to issue a refund.   Longer
expiration periods increase the chance that the exchange rate will
fluctuate a significant amount before payment is received.</p>

  <h3 id="requesting-payments">Requesting Payments</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Before requesting payment, your application must create a Bitcoin
address, or acquire an address from another program such as
Bitcoin Core.  Bitcoin addresses are described in detail in the
<a href="#transactions">Transactions</a> section. Also described in that section
are two important reasons to <a href="#avoiding-key-reuse">avoid using an address more than
once</a>—but a third reason applies especially to
payment requests:</p>

  <p>Using a separate address for each incoming payment makes it trivial to
determine which customers have paid their payment requests.  Your
applications need only track the association between a particular payment
request and the address used in it, and then scan the block chain for
transactions matching that address.</p>

  <p>The next subsections will describe in detail the following four
compatible ways to give the spender the address and amount to be paid.
For increased convenience and compatibility, providing all of these options in your
payment requests is recommended.</p>

  <ol>
    <li>
      <p>All wallet software lets its users paste in or manually enter an
address and amount into a payment screen. This is, of course,
inconvenient—but it makes an effective fallback option.</p>
    </li>
    <li>
      <p>Almost all desktop wallets can associate with <code class="highlighter-rouge">bitcoin:</code> URIs, so
spenders can click a link to pre-fill the payment screen. This also
works with many mobile wallets, but it generally does not work with
web-based wallets unless the spender installs a browser extension or
manually configures a URI handler.</p>
    </li>
    <li>
      <p>Most mobile wallets support scanning <code class="highlighter-rouge">bitcoin:</code> URIs encoded in a
QR code, and almost all wallets can display them for
accepting payment. While also handy for online orders, QR Codes are
especially useful for in-person purchases.</p>
    </li>
    <li>
      <p>Recent wallet updates add support for the new payment protocol providing
increased security, authentication of a receiver’s identity using X.509 certificates,
and other important features such as refunds.</p>
    </li>
  </ol>

  <p><img src="/img/icons/icon_warning.svg" alt="Warning icon" />
 <strong>Warning:</strong> Special care must be taken to avoid the theft of incoming
payments. In particular, private keys should not be stored on web servers,
and payment requests should be sent over HTTPS or other secure methods
to prevent man-in-the-middle attacks from replacing your Bitcoin address
with the attacker’s address.</p>

  <h4 id="plain-text">Plain Text</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>To specify an amount directly for copying and pasting, you must provide
the address, the amount, and the denomination. An expiration time for
the offer may also be specified.  For example:</p>

  <p>(Note: all examples in this section use testnet addresses.)</p>

  <div class="highlighter-rouge"><pre><code>Pay: mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN
Amount: 100 BTC
You must pay by: 2014-04-01 at 23:00 UTC
</code></pre>
  </div>

  <p>Indicating the denomination is critical. As of this writing, popular
Bitcoin wallet software defaults to denominating amounts in either bitcoins (BTC)
, millibitcoins (mBTC) or microbitcoins (uBTC, “bits”). Choosing between each unit is widely supported,
but other software also lets its users select denomination amounts from
some or all of the following options:</p>

  <table>
    <thead>
      <tr>
        <th>Bitcoins</th>
        <th>Unit (Abbreviation)</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1.0</td>
        <td>bitcoin (BTC)</td>
      </tr>
      <tr>
        <td>0.01</td>
        <td>bitcent (cBTC)</td>
      </tr>
      <tr>
        <td>0.001</td>
        <td>millibitcoin (mBTC)</td>
      </tr>
      <tr>
        <td>0.000001</td>
        <td>microbitcoin (uBTC, “bits”)</td>
      </tr>
      <tr>
        <td>0.00000001</td>
        <td>satoshi</td>
      </tr>
    </tbody>
  </table>

  <h4 id="bitcoin-uri">bitcoin: URI</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The <a href="/en/developer-guide#term-bitcoin-uri" title="A URI which allows receivers to encode payment details so spenders don't have to manually enter addresses and other details" id="term-bitcoin-uri" class="term"><code class="highlighter-rouge">bitcoin:</code> URI</a> scheme defined in BIP21 eliminates denomination
confusion and saves the spender from copying and pasting two separate
values. It also lets the payment request provide some additional
information to the spender. An example:</p>

  <div class="highlighter-rouge"><pre><code>bitcoin:mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN?amount=100
</code></pre>
  </div>

  <p>Only the address is required, and if it is the only thing
specified, wallets will pre-fill a payment request with it and let
the spender enter an amount. The amount specified is always in
decimal bitcoins (BTC).</p>

  <p>Two other parameters are widely supported. The
<a href="/en/developer-guide#term-label" title="The label parameter of a bitcoin: URI which provides the spender with the receiver's name (unauthenticated)" id="term-label" class="term"><code class="highlighter-rouge">label</code></a> parameter is generally used to
provide wallet software with the recipient’s name. The
<a href="/en/developer-guide#term-message" title="A parameter of bitcoin: URIs which allows the receiver to optionally specify a message to the spender" id="term-message" class="term"><code class="highlighter-rouge">message</code></a> parameter is generally used
to describe the payment request to the spender. Both the label and the
message are commonly stored by the spender’s wallet software—but they
are never added to the actual transaction, so other Bitcoin users cannot
see them. Both the label and the message must be <a href="https://tools.ietf.org/html/rfc3986">URI encoded</a>.</p>

  <p>All four parameters used together, with appropriate URI encoding, can be
seen in the line-wrapped example below.</p>

  <div class="highlighter-rouge"><pre><code>bitcoin:mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN\
?amount=0.10\
&amp;label=Example+Merchant\
&amp;message=Order+of+flowers+%26+chocolates
</code></pre>
  </div>

  <p>The URI scheme can be extended, as will be seen in the payment protocol
section below, with both new optional and required parameters. As of this
writing, the only widely-used parameter besides the four described above
is the payment protocol’s <code class="highlighter-rouge">r</code> parameter.</p>

  <p>Programs accepting URIs in any form must ask the user for permission
before paying unless the user has explicitly disabled prompting (as
might be the case for micropayments).</p>

  <h4 id="qr-codes">QR Codes</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>QR codes are a popular way to exchange <code class="highlighter-rouge">bitcoin:</code> URIs in person, in
images, or in videos. Most mobile Bitcoin wallet apps, and some desktop
wallets, support scanning QR codes to pre-fill their payment screens.</p>

  <p>The figure below shows the same <code class="highlighter-rouge">bitcoin:</code> URI code encoded as four
different <a href="/en/developer-guide#term-uri-qr-code" title="A QR code containing a bitcoin: URI" id="term-uri-qr-code" class="term">Bitcoin QR codes</a> at four
different error correction levels. The QR code can include the <code class="highlighter-rouge">label</code> and <code class="highlighter-rouge">message</code>
parameters—and any other optional parameters—but they were
omitted here to keep the QR code small and easy to scan with unsteady
or low-resolution mobile cameras.</p>

  <p><img src="/img/dev/en-qr-code.svg" alt="Bitcoin QR Codes" /></p>

  <p>The error correction is combined with a checksum to ensure the Bitcoin QR code
cannot be successfully decoded with data missing or accidentally altered,
so your applications should choose the appropriate level of error
correction based on the space you have available to display the code.
Low-level damage correction works well when space is limited, and
quartile-level damage correction helps ensure fast scanning when
displayed on high-resolution screens.</p>

  <h4 id="payment-protocol">Payment Protocol</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Bitcoin Core 0.9 supports the new <a href="/en/glossary/payment-protocol" title="The protocol defined in BIP70 (and other BIPs) which lets spenders get signed payment details from receivers." id="term-payment-protocol" class="term">payment protocol</a>. The payment protocol
adds many important features to payment requests:</p>

  <ul>
    <li>
      <p>Supports X.509 certificates and SSL encryption to verify receivers’ identity
and help prevent man-in-the-middle attacks.</p>
    </li>
    <li>
      <p>Provides more detail about the requested payment to spenders.</p>
    </li>
    <li>
      <p>Allows spenders to submit transactions directly to receivers without going
through the peer-to-peer network. This can speed up payment processing and
work with planned features such as child-pays-for-parent transaction fees
and offline NFC or Bluetooth-based payments.</p>
    </li>
  </ul>

  <p>Instead of being asked to pay a meaningless address, such as
“mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN”, spenders are asked to pay the
Common Name (CN) description from the receiver’s X.509 certificate, such
as “www.bitcoin.org”.</p>

  <p>To request payment using the payment protocol, you use an extended (but
backwards-compatible) <code class="highlighter-rouge">bitcoin:</code> URI.  For example:</p>

  <div class="highlighter-rouge"><pre><code>bitcoin:mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN\
?amount=0.10\
&amp;label=Example+Merchant\
&amp;message=Order+of+flowers+%26+chocolates\
&amp;r=https://example.com/pay/mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN
</code></pre>
  </div>

  <p>None of the parameters provided above, except <code class="highlighter-rouge">r</code>, are required for the
payment protocol—but your applications may include them for backwards
compatibility with wallet programs which don’t yet handle the payment
protocol.</p>

  <p>The <a href="/en/developer-guide#term-r-parameter" title="The payment request parameter in a bitcoin: URI" id="term-r-parameter" class="term"><code class="highlighter-rouge">r</code></a> parameter tells payment-protocol-aware wallet programs to ignore
the other parameters and fetch a PaymentRequest from the URL provided.
The browser, QR code reader, or other program processing the URI opens
the spender’s Bitcoin wallet program on the URI.</p>

  <p><img src="/img/dev/en-payment-protocol.svg" alt="BIP70 Payment Protocol" /></p>

  <p>The Payment Protocol is described in depth in BIP70, BIP71, and BIP72.
An example CGI program and description of all the parameters which can
be used in the Payment Protocol is provided in the Developer Examples
<a href="/en/developer-examples#payment-protocol">Payment Protocol</a> subsection. In this
subsection, we will briefly describe in story format how the Payment
Protocol is typically used.</p>

  <p>Charlie, the client, is shopping on a website run by Bob, the
businessman. Charlie adds a few items to his shopping cart and clicks
the “Checkout With Bitcoin” button.</p>

  <p>Bob’s server automatically adds the following information to its
invoice database:</p>

  <ul>
    <li>
      <p>The details of Charlie’s order, including items ordered and
shipping address.</p>
    </li>
    <li>
      <p>An order total in satoshis, perhaps created by converting prices in
fiat to prices in satoshis.</p>
    </li>
    <li>
      <p>An expiration time when that total will no longer be acceptable.</p>
    </li>
    <li>
      <p>A pubkey script to which Charlie should send payment. Typically this
will be a P2PKH or P2SH pubkey script containing a unique (never
before used) secp256k1 public key.</p>
    </li>
  </ul>

  <p>After adding all that information to the database, Bob’s server displays
a <code class="highlighter-rouge">bitcoin:</code> URI for Charlie to click to pay.</p>

  <p>Charlie clicks on the <code class="highlighter-rouge">bitcoin:</code> URI in his browser. His browser’s URI
handler sends the URI to his wallet program. The wallet is aware of the
Payment Protocol, so it parses the <code class="highlighter-rouge">r</code> parameter and sends an HTTP GET
to that URL looking for a PaymentRequest message.</p>

  <p>The PaymentRequest message returned may include private information, such as Charlie’s
mailing address, but the wallet must be able to access it without using prior
authentication, such as HTTP cookies, so a publicly-accessible HTTPS URL
with a guess-resistant part is typically used. The
unique public key created for the payment request can be used to create
a unique identifier. This is why, in the example URI above, the PaymentRequest
URL contains the P2PKH address:
<code class="highlighter-rouge">https://example.com/pay/mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN</code></p>

  <p>After receiving the HTTP GET to the URL above, the
PaymentRequest-generating CGI program on Bob’s webserver takes the
unique identifier from the URL and looks up the corresponding details in
the database. It then creates a PaymentDetails message with the
following information:</p>

  <ul>
    <li>
      <p>The amount of the order in satoshis and the pubkey script to be paid.</p>
    </li>
    <li>
      <p>A memo containing the list of items ordered, so Charlie knows what
he’s paying for.  It may also include Charlie’s mailing address so he can
double-check it.</p>
    </li>
    <li>
      <p>The time the PaymentDetails message was created plus the time
it expires.</p>
    </li>
    <li>
      <p>A URL to which Charlie’s wallet should send its completed transaction.</p>
    </li>
  </ul>

  <p>That PaymentDetails message is put inside a PaymentRequest message.
The payment request lets Bob’s server sign the entire Request with the
server’s X.509 SSL certificate.  (The Payment Protocol has been designed
to allow other signing methods in the future.)  Bob’s server sends the
payment request to Charlie’s wallet in the reply to the HTTP GET.</p>

  <p><img src="/img/dev/en-btcc-payment-request.png" alt="Bitcoin Core Showing Validated Payment Request" /></p>

  <p>Charlie’s wallet receives the PaymentRequest message, checks its signature, and
then displays the details from the PaymentDetails message to Charlie. Charlie
agrees to pay, so the wallet constructs a payment to the pubkey script
Bob’s server provided. Unlike a traditional Bitcoin payment, Charlie’s
wallet doesn’t necessarily automatically broadcast this payment to the
network. Instead, the wallet constructs a Payment message and sends it to
the URL provided in the PaymentDetails message as an HTTP POST. Among
other things, the Payment message contains:</p>

  <ul>
    <li>
      <p>The signed transaction in which Charlie pays Bob.</p>
    </li>
    <li>
      <p>An optional memo Charlie can send to Bob. (There’s no guarantee that
Bob will read it.)</p>
    </li>
    <li>
      <p>A refund address (pubkey script) which Bob can pay if he needs to
return some or all of Charlie’s satoshis.</p>
    </li>
  </ul>

  <p>Bob’s server receives the Payment message, verifies the transaction pays
the requested amount to the address provided, and then broadcasts the
transaction to the network. It also replies to the HTTP POSTed Payment
message with a PaymentACK message, which includes an optional memo
from Bob’s server thanking Charlie for his patronage and providing other
information about the order, such as the expected arrival date.</p>

  <p>Charlie’s wallet sees the PaymentACK and tells Charlie that the payment
has been sent. The PaymentACK doesn’t mean that Bob has verified
Charlie’s payment—see the Verifying Payment subsection below—but it does mean
that Charlie can go do something else while the transaction gets confirmed.
After Bob’s server verifies from the block chain that Charlie’s
transaction has been suitably confirmed, it authorizes shipping
Charlie’s order.</p>

  <p>In the case of a dispute, Charlie can generate a cryptographically-proven
<a href="/en/developer-guide#term-receipt" title="A cryptographically-verifiable receipt created using parts of a payment request and a confirmed transaction" id="term-receipt" class="term">receipt</a> out of the various signed or
otherwise-proven information.</p>

  <ul>
    <li>
      <p>The PaymentDetails message signed by Bob’s webserver proves Charlie
received an invoice to pay a specified pubkey script for a specified
number of satoshis for goods specified in the memo field.</p>
    </li>
    <li>
      <p>The Bitcoin block chain can prove that the pubkey script specified by
Bob was paid the specified number of satoshis.</p>
    </li>
  </ul>

  <p>If a refund needs to be issued, Bob’s server can safely pay the
refund-to pubkey script provided by Charlie.  See the Refunds section below
for more details.</p>

  <h3 id="verifying-payment">Verifying Payment</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>As explained in the <a href="/en/developer-guide#transactions" title="A transaction spending satoshis">Transactions</a> and <a href="/en/developer-guide#block-chain">Block Chain</a> sections, broadcasting
a transaction to the network doesn’t ensure that the receiver gets
paid. A malicious spender can create one transaction that pays the
receiver and a second one that pays the same input back to himself. Only
one of these transactions will be added to the block chain, and nobody
can say for sure which one it will be.</p>

  <p>Two or more transactions spending the same input are commonly referred
to as a <a href="/en/glossary/double-spend" title="A transaction that uses the same input as an already broadcast transaction. The attempt of duplication, deceit, or conversion,  will be adjudicated when only one of the transactions is recorded in the blockchain." id="term-double-spend" class="term">double spend</a>.</p>

  <p>Once the transaction is included in a block, double spends are
impossible without modifying block chain history to replace the
transaction, which is quite difficult. Using this system,
the Bitcoin protocol can give each of your transactions an updating confidence 
score based on the number of blocks which would need to be modified to replace 
a transaction. For each block, the transaction gains one <a href="/en/glossary/confirmation-score" title="A score indicating the number of blocks on the best block chain that would need to be modified to remove or modify a particular transaction. A confirmed transaction has a confirmation score of one or higher." id="term-confirmation" class="term">confirmation</a>. Since
modifying blocks is quite difficult, higher confirmation scores indicate 
greater protection.</p>

  <p><strong>0 confirmations</strong>: The transaction has been broadcast but is still not 
included in any block. Zero confirmation transactions (unconfirmed
transactions) should generally not be
trusted without risk analysis. Although miners usually confirm the first 
transaction they receive, fraudsters may be able to manipulate the
network into including their version of a transaction.</p>

  <p><strong>1 confirmation</strong>: The transaction is included in the latest block and 
double-spend risk decreases dramatically. Transactions which pay
sufficient transaction fees need 10 minutes on average to receive one
confirmation. However, the most recent block gets replaced fairly often by
accident, so a double spend is still a real possibility.</p>

  <p><strong>2 confirmations</strong>: The most recent block was chained to the block which 
includes the transaction. As of March 2014, two block replacements were 
exceedingly rare, and a two block replacement attack was impractical without 
expensive mining equipment.</p>

  <p><strong>6 confirmations</strong>: The network has spent about an hour working to protect 
the transaction against double spends and the transaction is buried under six 
blocks. Even a reasonably lucky attacker would require a large percentage of 
the total network hashing power to replace six blocks. Although this number is 
somewhat arbitrary, software handling high-value transactions, or otherwise at 
risk for fraud, should wait for at least six confirmations before treating a 
payment as accepted.</p>

  <p>Bitcoin Core provides several RPCs which can provide your program with the 
confirmation score for transactions in your wallet or arbitrary transactions. 
For example, the <code class="highlighter-rouge">listunspent</code> RPC provides an array of every satoshi you can 
spend along with its confirmation score.</p>

  <p>Although confirmations provide excellent double-spend protection most of the 
time, there are at least three cases where double-spend risk analysis can be 
required:</p>

  <ol>
    <li>
      <p>In the case when the program or its user cannot wait for a confirmation and 
wants to accept unconfirmed payments.</p>
    </li>
    <li>
      <p>In the case when the program or its user is accepting high value 
transactions and cannot wait for at least six confirmations or more.</p>
    </li>
    <li>
      <p>In the case of an implementation bug or prolonged attack against Bitcoin 
which makes the system less reliable than expected.</p>
    </li>
  </ol>

  <p>An interesting source of double-spend risk analysis can be acquired by 
connecting to large numbers of Bitcoin peers to track how transactions and 
blocks differ from each other. Some third-party APIs can provide you with this 
type of service.</p>

  <!-- TODO Example of double spend risk analysis using bitcoinj, eventually? -->

  <p>For example, unconfirmed transactions can be compared among all connected peers 
to see if any UTXO is used in multiple unconfirmed transactions, indicating a 
double-spend attempt, in which case the payment can be refused until it is 
confirmed. Transactions can also be ranked by their transaction fee to
estimate the amount of time until they’re added to a block.</p>

  <p>Another example could be to detect a fork when multiple peers report differing 
block header hashes at the same block height. Your program can go into a safe mode if the 
fork extends for more than two blocks, indicating a possible problem with the 
block chain. For more details, see the <a href="/en/developer-guide#detecting-forks">Detecting Forks
subsection</a>.</p>

  <p>Another good source of double-spend protection can be human intelligence. For 
example, fraudsters may act differently from legitimate customers, letting 
savvy merchants manually flag them as high risk. Your program can provide a 
safe mode which stops automatic payment acceptance on a global or per-customer 
basis.</p>

  <h3 id="issuing-refunds">Issuing Refunds</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Occasionally receivers using your applications will need to issue
refunds. The obvious way to do that, which is very unsafe, is simply
to return the satoshis to the pubkey script from which they came.
For example:</p>

  <ul>
    <li>
      <p>Alice wants to buy a widget from Bob, so Bob gives Alice a price and
Bitcoin address.</p>
    </li>
    <li>
      <p>Alice opens her wallet program and sends some satoshis to that
address. Her wallet program automatically chooses to spend those
satoshis from one of its unspent outputs, an output corresponding to
the Bitcoin address mjSk1Ny9spzU2fouzYgLqGUD8U41iR35QN.</p>
    </li>
    <li>
      <p>Bob discovers Alice paid too many satoshis. Being an honest fellow,
Bob refunds the extra satoshis to the mjSk… address.</p>
    </li>
  </ul>

  <p>This seems like it should work, but Alice is using a centralized
multi-user web wallet which doesn’t give unique addresses to each user,
so it has no way to know that Bob’s refund is meant for Alice.  Now the
refund is a unintentional donation to the company behind the centralized
wallet, unless Alice opens a support ticket and proves those satoshis
were meant for her.</p>

  <p>This leaves receivers only two correct ways to issue refunds:</p>

  <ul>
    <li>
      <p>If an address was copy-and-pasted or a basic <code class="highlighter-rouge">bitcoin:</code> URI was used,
contact the spender directly and ask them to provide a refund address.</p>
    </li>
    <li>
      <p>If the payment protocol was used, send the refund to the output
listed in the <code class="highlighter-rouge">refund_to</code> field of the Payment message.</p>
    </li>
  </ul>

  <p>Note: it would be wise to contact the
spender directly if the refund is being issued a long time after the
original payment was made.
This allows you to ensure the user still has access to the key or keys
for the <code class="highlighter-rouge">refund_to</code> address.</p>

  <h3 id="disbursing-income-limiting-forex-risk">Disbursing Income (Limiting Forex Risk)</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Many receivers worry that their satoshis will be less valuable in the
future than they are now, called foreign exchange (forex) risk. To limit
forex risk, many receivers choose to disburse newly-acquired payments
soon after they’re received.</p>

  <p>If your application provides this business logic, it will need to choose
which outputs to spend first.  There are a few different algorithms
which can lead to different results.</p>

  <ul>
    <li>
      <p>A merge avoidance algorithm makes it harder for outsiders looking
at block chain data to figure out how many satoshis the receiver has
earned, spent, and saved.</p>
    </li>
    <li>
      <p>A last-in-first-out (LIFO) algorithm spends newly acquired satoshis
while there’s still double spend risk, possibly pushing that risk on
to others. This can be good for the receiver’s balance sheet but
possibly bad for their reputation.</p>
    </li>
    <li>
      <p>A first-in-first-out (FIFO) algorithm spends the oldest satoshis
first, which can help ensure that the receiver’s payments always
confirm, although this has utility only in a few edge cases.</p>
    </li>
  </ul>

  <h4 id="merge-avoidance">Merge Avoidance</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>When a receiver receives satoshis in an output, the spender can track
(in a crude way) how the receiver spends those satoshis. But the spender
can’t automatically see other satoshis paid to the receiver by other
spenders as long as the receiver uses unique addresses for each
transaction.</p>

  <p>However, if the receiver spends satoshis from two different spenders in
the same transaction, each of those spenders can see the other spender’s
payment.  This is called a <a href="/en/developer-guide#term-merge" title="Spending, in the same transaction, multiple outputs which can be traced back to different previous spenders, leaking information about how many satoshis you control" id="term-merge" class="term">merge</a>, and the more a receiver merges
outputs, the easier it is for an outsider to track how many satoshis the
receiver has earned, spent, and saved.</p>

  <p><a href="/en/developer-guide#term-merge-avoidance" title="A strategy for selecting which outputs to spend that avoids merging outputs with different histories that could leak private information" id="term-merge-avoidance" class="term">Merge avoidance</a> means trying to avoid spending unrelated outputs in the
same transaction. For persons and businesses which want to keep their
transaction data secret from other people, it can be an important strategy.</p>

  <p>A crude merge avoidance strategy is to try to always pay with the
smallest output you have which is larger than the amount being
requested. For example, if you have four outputs holding, respectively,
100, 200, 500, and 900 satoshis, you would pay a bill for 300 satoshis
with the 500-satoshi output. This way, as long as you have outputs
larger than your bills, you avoid merging.</p>

  <p>More advanced merge avoidance strategies largely depend on enhancements
to the payment protocol which will allow payers to avoid merging by
intelligently distributing their payments among multiple outputs
provided by the receiver.</p>

  <h4 id="last-in-first-out-lifo">Last In, First Out (LIFO)</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Outputs can be spent as soon as they’re received—even before they’re
confirmed. Since recent outputs are at the greatest risk of being
double-spent, spending them before older outputs allows the spender to
hold on to older confirmed outputs which are much less likely to be
double-spent.</p>

  <p>There are two closely-related downsides to LIFO:</p>

  <ul>
    <li>
      <p>If you spend an output from one unconfirmed transaction in a second
transaction, the second transaction becomes invalid if transaction
malleability changes the first transaction.</p>
    </li>
    <li>
      <p>If you spend an output from one unconfirmed transaction in a second
transaction and the first transaction’s output is successfully double
spent to another output, the second transaction becomes invalid.</p>
    </li>
  </ul>

  <p>In either of the above cases, the receiver of the second transaction
will see the incoming transaction notification disappear or turn into an
error message.</p>

  <p>Because LIFO puts the recipient of secondary transactions in as much
double-spend risk as the recipient of the primary transaction, they’re
best used when the secondary recipient doesn’t care about the
risk—such as an exchange or other service which is going to wait for
six confirmations whether you spend old outputs or new outputs.</p>

  <p>LIFO should not be used when the primary transaction recipient’s
reputation might be at stake, such as when paying employees. In these
cases, it’s better to wait for transactions to be fully verified (see
the <a href="/en/developer-guide#verifying-payment">Verification subsection</a> above) before using them to make payments.</p>

  <h4 id="first-in-first-out-fifo">First In, First Out (FIFO)</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The oldest outputs are the most reliable, as the longer it’s been since
they were received, the more blocks would need to be modified to double
spend them. However, after just a few blocks, a point of rapidly
diminishing returns is reached. The <a href="https://bitcoin.org/en/bitcoin-paper">original Bitcoin paper</a>
predicts the chance of an attacker being able to modify old blocks,
assuming the attacker has 30% of the total network hashing power:</p>

  <table>
    <thead>
      <tr>
        <th>Blocks</th>
        <th>Chance of successful modification</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>5</td>
        <td>17.73523%</td>
      </tr>
      <tr>
        <td>10</td>
        <td>4.16605%</td>
      </tr>
      <tr>
        <td>15</td>
        <td>1.01008%</td>
      </tr>
      <tr>
        <td>20</td>
        <td>0.24804%</td>
      </tr>
      <tr>
        <td>25</td>
        <td>0.06132%</td>
      </tr>
      <tr>
        <td>30</td>
        <td>0.01522%</td>
      </tr>
      <tr>
        <td>35</td>
        <td>0.00379%</td>
      </tr>
      <tr>
        <td>40</td>
        <td>0.00095%</td>
      </tr>
      <tr>
        <td>45</td>
        <td>0.00024%</td>
      </tr>
      <tr>
        <td>50</td>
        <td>0.00006%</td>
      </tr>
    </tbody>
  </table>

  <p>FIFO does have a small advantage when it comes to transaction fees, as
older outputs may be eligible for inclusion in the 50,000 bytes set
aside for no-fee-required high-priority transactions by miners running the default Bitcoin Core
codebase.  However, with transaction fees being so low, this is not a
significant advantage.</p>

  <p>The only practical use of FIFO is by receivers who spend all or most
of their income within a few blocks, and who want to reduce the
chance of their payments becoming accidentally invalid. For example,
a receiver who holds each payment for six confirmations, and then
spends 100% of verified payments to vendors and a savings account on
a bi-hourly schedule.</p>

  <h3 id="rebilling-recurring-payments">Rebilling Recurring Payments</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_payment_processing.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_payment_processing.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_payment_processing.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_payment_processing.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Automated recurring payments are not possible with decentralized Bitcoin
wallets. Even if a wallet supported automatically sending non-reversible
payments on a regular schedule, the user would still need to start the
program at the appointed time, or leave it running all the time
unprotected by encryption.</p>

  <p>This means automated recurring Bitcoin payments can only be made from a
centralized server which handles satoshis on behalf of its spenders. In
practice, receivers who want to set prices in fiat terms must also let
the same centralized server choose the appropriate exchange rate.</p>

  <p>Non-automated rebilling can be managed by the same mechanism used before
credit-card recurring payments became common: contact the spender and
ask them to pay again—for example, by sending them a PaymentRequest
<code class="highlighter-rouge">bitcoin:</code> URI in an HTML email.</p>

  <p>In the future, extensions to the payment protocol and new wallet
features may allow some wallet programs to manage a list of recurring
transactions. The spender will still need to start the program on a
regular basis and authorize payment—but it should be easier and more
secure for the spender than clicking an emailed invoice, increasing the
chance receivers get paid on time.</p>

  <h2 id="operating-modes">Operating Modes</h2>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_operating_modes.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_operating_modes.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_operating_modes.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_operating_modes.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Currently there are two primary methods of validating the block chain as a client: Full nodes and SPV clients. Other methods, such as server-trusting methods, are not discussed as they are not recommended.</p>

  <h3 id="full-node">Full Node</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_operating_modes.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_operating_modes.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_operating_modes.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_operating_modes.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The first and most secure model is the one followed by Bitcoin Core, also known as a “thick” or “full chain” client. This security model assures the validity of the block chain by downloading and validating blocks from the genesis block all the way to the most recently discovered block. This is known as using the <em>height</em> of a particular block to verify the client’s view of the network.</p>

  <p>For a client to be fooled, an adversary would need to give a complete alternative block chain history that is of greater difficulty than the current “true” chain, which is computationally expensive (if not impossible) due to the fact that the chain with the most cumulative proof of work is by definition the “true” chain. Due to the computational difficulty required to generate a new block at the tip of the chain, the ability to fool a full node becomes very expensive after 6 confirmations. This form of verification is highly resistent to sybil attacks—only a single honest network peer is required in order to receive and verify the complete state of the “true” block chain.</p>

  <p><img src="/img/dev/en-block-height-vs-depth.svg" alt="Block Height Compared To Block Depth" /></p>

  <h3 id="simplified-payment-verification-spv">Simplified Payment Verification (SPV)</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_operating_modes.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_operating_modes.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_operating_modes.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_operating_modes.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>An alternative approach detailed in the <a href="https://bitcoin.org/en/bitcoin-paper">original Bitcoin paper</a> is a client that only downloads the headers of blocks during the initial syncing process and then requests transactions from full nodes as needed. This scales linearly with the height of the block chain at only 80 bytes per block header, or up to 4.2MB per year, regardless of total block size.</p>

  <p>As described in the white paper, the merkle root in the block header along with a merkle branch can prove to the SPV client that the transaction in question is embedded in a block in the block chain. This does not guarantee validity of the transactions that are embedded. Instead it demonstrates the amount of work required to perform a double-spend attack.</p>

  <p>The block’s depth in the block chain corresponds to the cumulative difficulty that has been performed to build on top of that particular block. The SPV client knows the merkle root and associated transaction information, and requests the respective merkle branch from a full node. Once the merkle branch has been retrieved, proving the existence of the transaction in the block, the SPV client can then look to block <em>depth</em> as a proxy for transaction validity and security. The cost of an attack on a user by a malicious node who inserts an invalid transaction grows with the cumulative difficulty built on top of that block, since the malicious node alone will be mining this forged chain.</p>

  <h4 id="potential-spv-weaknesses">Potential SPV Weaknesses</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_operating_modes.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_operating_modes.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_operating_modes.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_operating_modes.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>If implemented naively, an SPV client has a few important weaknesses.</p>

  <p>First, while the SPV client can not be easily fooled into thinking a transaction is in a block when it is not, the reverse is not true. A full node can simply lie by omission, leading an SPV client to believe a transaction has not occurred. This can be considered a form of Denial of Service. One mitigation strategy is to connect to a number of full nodes, and send the requests to each node. However this can be defeated by network partitioning or Sybil attacks, since identities are essentially free, and can be bandwidth intensive. Care must be taken to ensure the client is not cut off from honest nodes.</p>

  <p>Second, the SPV client only requests transactions from full nodes corresponding to keys it owns. If the SPV client downloads all blocks and then discards unneeded ones, this can be extremely bandwidth intensive. If they simply ask full nodes for blocks with specific transactions, this allows full nodes a complete view of the public addresses that correspond to the user. This is a large privacy leak, and allows for tactics such as denial of service for clients, users, or addresses that are disfavored by those running full nodes, as well as trivial linking of funds. A client could simply spam many fake transaction requests, but this creates a large strain on the SPV client, and can end up defeating the purpose of thin clients altogether.</p>

  <p>To mitigate the latter issue, Bloom filters have been implemented as a method of obfuscation and compression of block data requests.</p>

  <h4 id="bloom-filters">Bloom Filters</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_operating_modes.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_operating_modes.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_operating_modes.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_operating_modes.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>A Bloom filter is a space-efficient probabilistic data structure that is used to test membership of an element. The data structure achieves great data compression at the expense of a prescribed false positive rate.</p>

  <p>A Bloom filter starts out as an array of n bits all set to 0. A set of k random hash functions are chosen, each of which output<!--noref--> a single integer between the range of 1 and n.</p>

  <p>When adding an element to the Bloom filter, the element is hashed k times separately, and for each of the k outputs<!--noref-->, the corresponding Bloom filter bit at that index is set to 1.</p>

  <!-- Add picture here from wikipedia to explain the bits -->

  <p>Querying of the Bloom filter is done by using the same hash functions as before. If all k bits accessed in the bloom filter are set to 1, this demonstrates with high probability that the element lies in the set. Clearly, the k indices could have been set to 1 by the addition of a combination of other elements in the domain, but the parameters allow the user to choose the acceptable false positive rate.</p>

  <p>Removal of elements can only be done by scrapping the bloom filter and re-creating it from scratch.</p>

  <h4 id="application-of-bloom-filters">Application Of Bloom Filters</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_operating_modes.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_operating_modes.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_operating_modes.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_operating_modes.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Rather than viewing the false positive rates as a liability, it is used to create a tunable parameter that represents the desired privacy level and bandwidth trade-off. A SPV client creates their Bloom filter and sends it to a full node using the message <code class="highlighter-rouge">filterload</code>, which sets the filter for which transactions are desired. The command <code class="highlighter-rouge">filteradd</code> allows addition of desired data to the filter without needing to send a totally new Bloom filter, and <code class="highlighter-rouge">filterclear</code> allows the connection to revert to standard block discovery mechanisms. If the filter has been loaded, then full nodes will send a modified form of blocks, called a merkle block. The merkle block is simply the block header with the merkle branch associated with the set Bloom filter.</p>

  <p>An SPV client can not only add transactions as elements to the filter, but also public keys, data from signature
scripts and pubkey scripts, and more. This enables P2SH transaction finding.</p>

  <p>If a user is more privacy-conscious, he can set the Bloom filter to include more false positives, at the expense of extra bandwidth used for transaction discovery. If a user is on a tight bandwidth budget, he can set the false-positive rate to low, knowing that this will allow full nodes a clear view of what transactions are associated with his client.</p>

  <p><strong>Resources:</strong> <a href="http://bitcoinj.github.io">BitcoinJ</a>, a Java implementation of Bitcoin that is based on the SPV security model and Bloom filters. Used in most Android wallets.</p>

  <p>Bloom filters were standardized for use via <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">BIP37</a>. Review the BIP for implementation details.</p>

  <h3 id="future-proposals">Future Proposals</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_operating_modes.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_operating_modes.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_operating_modes.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_operating_modes.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>There are future proposals such as Unspent Transaction Output (UTXO) commitments in the block chain to find a more satisfactory middle-ground for clients between needing a complete copy of the block chain, or trusting that a majority of your connected peers are not lying. UTXO commitments would enable a very secure client using a finite amount of storage using a data structure that is authenticated in the block chain. These type of proposals are, however, in very early stages, and will require soft forks in the network.</p>

  <p>Until these types of operating modes are implemented, modes should be chosen based on the likely threat model, computing and bandwidth constraints, and liability in bitcoin value.</p>

  <p><strong>Resources:</strong> <a href="https://bitcointalk.org/index.php?topic=88208.0">Original Thread on UTXO Commitments</a>, <a href="https://github.com/maaku/bips/blob/master/drafts/auth-trie.mediawiki">Authenticated Prefix Trees BIP Proposal</a></p>

  <h2 id="p2p-network">P2P Network</h2>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The Bitcoin network protocol allows full nodes
(peers) to collaboratively maintain a
<a href="/en/developer-guide#term-network" title="The Bitcoin P2P network which broadcasts transactions and blocks" id="term-network" class="term">peer-to-peer network</a> for block and
transaction exchange. Full nodes download and verify every block and transaction
prior to relaying them to other nodes. Archival nodes are full nodes which
store the entire blockchain and can serve historical blocks to other nodes.
Pruned nodes are full nodes which do not store the entire blockchain. Many SPV 
clients also use the Bitcoin network protocol to connect to full nodes.</p>

  <p>Consensus rules do not cover networking, so Bitcoin programs may use
alternative networks and protocols, such as the <a href="https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03189.html">high-speed block relay
network</a> used by some miners and the <a href="https://github.com/spesmilo/electrum-server">dedicated transaction
information servers</a> used by some wallets that provide
SPV-level security.</p>

  <p>To provide practical examples of the Bitcoin peer-to-peer network, this
section uses Bitcoin Core as a representative full node and <a href="http://bitcoinj.github.io">BitcoinJ</a>
as a representative SPV client. Both programs are flexible, so only
default behavior is described. Also, for privacy, actual IP addresses
in the example output below have been replaced with <a href="http://tools.ietf.org/html/rfc5737">RFC5737</a> reserved
IP addresses.</p>

  <h3 id="peer-discovery">Peer Discovery</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>When started for the first time, programs don’t know the IP
addresses of any active full nodes. In order to discover some IP
addresses, they query one or more DNS names (called <a href="/en/glossary/dns-seed" title="A DNS server which returns IP addresses of full nodes on the Bitcoin network to assist in peer discovery." id="term-dns-seed" class="term">DNS seeds</a>)
hardcoded into Bitcoin Core and
BitcoinJ. The response to the lookup should include one or more <a href="http://tools.ietf.org/html/rfc1035#section-3.2.2">DNS
A records</a> with the IP addresses of full nodes that may accept new
incoming connections. For example, using the <a href="https://en.wikipedia.org/wiki/Dig_%28Unix_command%29">Unix <code class="highlighter-rouge">dig</code>
command</a>:</p>

  <div class="highlighter-rouge"><pre><code>;; QUESTION SECTION:
;seed.bitcoin.sipa.be.	    IN  A

;; ANSWER SECTION:
seed.bitcoin.sipa.be.	60  IN  A  192.0.2.113
seed.bitcoin.sipa.be.	60  IN  A  198.51.100.231
seed.bitcoin.sipa.be.	60  IN  A  203.0.113.183
[...]
</code></pre>
  </div>

  <p>The DNS seeds are maintained by Bitcoin community members: some of them
provide dynamic DNS seed servers which automatically get IP addresses
of active nodes by scanning the network; others provide static DNS
seeds that are updated manually and are more likely to provide IP
addresses for inactive nodes. In either case, nodes are added to the
DNS seed if they run on the default Bitcoin ports of 8333 for mainnet
or 18333 for testnet.</p>

  <!-- paragraph below based on Greg Maxwell's email in
     http://comments.gmane.org/gmane.comp.bitcoin.devel/5378 -->

  <p>DNS seed results are not authenticated and a malicious seed operator or
network man-in-the-middle attacker can return only IP addresses of
nodes controlled by the attacker, isolating a program on the attacker’s
own network and allowing the attacker to feed it bogus transactions and
blocks.  For this reason, programs should not rely on DNS seeds
exclusively.</p>

  <p>Once a program has connected to the network, its peers can begin to send
it <code class="highlighter-rouge">addr</code>
(address<!--noref-->) messages with the IP addresses and port numbers of
other peers on the network, providing a fully decentralized method of
peer discovery. Bitcoin Core keeps a record of known peers in a
persistent on-disk database which usually allows it to connect directly
to those peers on subsequent startups without having to use DNS seeds.</p>

  <p>However, peers often leave the network or change IP addresses, so
programs may need to make several different connection attempts at
startup before a successful connection is made. This can add a
significant delay to the amount of time it takes to connect to the
network, forcing a user to wait before sending a transaction or checking
the status of payment.</p>

  <!-- reference for "Bitcoin Core...11 seconds" below:
     https://github.com/bitcoin/bitcoin/pull/4559 -->

  <p>To avoid this possible delay, BitcoinJ always uses dynamic DNS seeds to
get IP addresses for nodes believed to be currently active.
Bitcoin Core also tries to strike a balance between minimizing delays
and avoiding unnecessary DNS seed use: if Bitcoin Core has entries in
its peer database, it spends up to 11 seconds attempting to connect to
at least one of them before falling back to seeds; if a connection is
made within that time, it does not query any seeds.</p>

  <!-- reference for Bitcoin Core behavior described below: search for
"FixedSeeds" in src/net.cpp; BitcoinJ has IPv4 seeds in its chainparams
and a function to use them, but I don't see that function being used in
any of the examples/wallet templates (but I'm not Java fluent, so
maybe PEBKAC). -@harding -->

  <p>Both Bitcoin Core and BitcoinJ also include a hardcoded list of IP
addresses and port numbers to several dozen nodes which were active
around the time that particular version of the software was first
released. Bitcoin Core will start attempting to connect to these nodes
if none of the DNS seed servers have responded to a query within 60
seconds, providing an automatic fallback option.</p>

  <p>As a manual fallback option, Bitcoin Core also provides several
command-line connection options, including the ability to get a list of
peers from a specific node by IP address, or to make a persistent
connection to a specific node by IP address.  See the <code class="highlighter-rouge">-help</code> text for
details.  BitcoinJ can be programmed to do the same thing.</p>

  <p><strong>Resources:</strong> <a href="https://github.com/sipa/bitcoin-seeder">Bitcoin Seeder</a>, the program run by several of the
seeds used by Bitcoin Core and BitcoinJ. The Bitcoin Core <a href="https://github.com/dashpay/dash/blob/master/doc/dnsseed-policy.md">DNS Seed
Policy</a>.  The hardcoded list of IP addresses used by Bitcoin Core and
BitcoinJ is generated using the <a href="https://github.com/dashpay/dash/tree/master/contrib/seeds">makeseeds script</a>.</p>

  <h3 id="connecting-to-peers">Connecting To Peers</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Connecting to a peer is done by sending a <code class="highlighter-rouge">version</code> message, which
contains your version number, block, and current time to the remote
node. The remote node responds with its own <code class="highlighter-rouge">version</code> message. Then both
nodes send a <code class="highlighter-rouge">verack</code> message to the other node to indicate the
connection has been established.</p>

  <p>Once connected, the client can send to the remote node <code class="highlighter-rouge">getaddr</code> and <code class="highlighter-rouge">addr</code> messages to gather additional peers.</p>

  <p>In order to maintain a connection with a peer, nodes by default will send a message to peers before 30 minutes of inactivity. If 90 minutes pass without a message being received by a peer, the client will assume that connection has closed.</p>

  <h3 id="initial-block-download">Initial Block Download</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Before a full node can validate unconfirmed transactions and
recently-mined blocks, it must download and validate all blocks from
block 1 (the block after the hardcoded genesis block) to the current tip
of the best block chain. This is the Initial Block Download (IBD) or
initial sync.</p>

  <p>Although the word “initial” implies this method is only used once, it
can also be used any time a large number of blocks need to be
downloaded, such as when a previously-caught-up node has been offline
for a long time. In this case, a node can use the IBD method to download
all the blocks which were produced since the last time it was online.</p>

  <p>Bitcoin Core uses the IBD method any time the last block on its local
best block chain has a block header time more than 24 hours in the past.
Bitcoin Core 0.10.0 will also perform IBD if its local best block chain is
more than 144 blocks lower than its local best header chain (that is,
the local block chain is more than about 24 hours in the past).</p>

  <h4 id="blocks-first">Blocks-First</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Bitcoin Core (up until version <a href="/en/release/v0.9.3">0.9.3</a>) uses a
simple initial block download (IBD) method we’ll call <em>blocks-first</em>.
The goal is to download the blocks from the best block chain in sequence.</p>

  <p><img src="/img/dev/en-blocks-first-flowchart.svg" alt="Overview Of Blocks-First Method" /></p>

  <p>The first time a node is started, it only has a single block in its
local best block chain—the hardcoded genesis block (block 0).  This
node chooses a remote peer, called the sync node, and sends it the
<code class="highlighter-rouge">getblocks</code> message illustrated below.</p>

  <p><img src="/img/dev/en-ibd-getblocks.svg" alt="First GetBlocks Message Sent During IBD" /></p>

  <p>In the header hashes field of the <code class="highlighter-rouge">getblocks</code> message, this new node
sends the header hash of the only block it has, the genesis block
(6fe2…0000 in internal byte order).  It also sets the stop hash field
to all zeroes to request a maximum-size response.</p>

  <p>Upon receipt of the <code class="highlighter-rouge">getblocks</code> message, the sync node takes the first
(and only) header hash and searches its local best block chain for a
block with that header hash. It finds that block 0 matches, so it
replies with 500 block inventories (the maximum response to a
<code class="highlighter-rouge">getblocks</code> message) starting from block 1. It sends these inventories
in the <code class="highlighter-rouge">inv</code> message illustrated below.</p>

  <p><img src="/img/dev/en-ibd-inv.svg" alt="First Inv Message Sent During IBD" /></p>

  <p>Inventories are unique identifiers for information on the network. Each
inventory contains a type field and the unique identifier for an
instance of the object. For blocks, the unique identifier is a hash of
the block’s header.</p>

  <p>The block inventories appear in the <code class="highlighter-rouge">inv</code> message in the same order they
appear in the block chain, so this first <code class="highlighter-rouge">inv</code> message contains
inventories for blocks 1 through 501. (For example, the hash of block 1
is 4860…0000 as seen in the illustration above.)</p>

  <p>The IBD node uses the received inventories to request 128 blocks from
the sync node in the <code class="highlighter-rouge">getdata</code> message illustrated below.</p>

  <p><img src="/img/dev/en-ibd-getdata.svg" alt="First GetData Message Sent During IBD" /></p>

  <p>It’s important to blocks-first nodes that the blocks be requested and
sent in order because each block header references the header hash of
the preceding block. That means the IBD node can’t fully validate a
block until its parent block has been received. Blocks that can’t be
validated because their parents haven’t been received are called orphan
blocks; a subsection below describes them in more detail.</p>

  <p>Upon receipt of the <code class="highlighter-rouge">getdata</code> message, the sync node replies with each
of the blocks requested. Each block is put into serialized block format
and sent in a separate <code class="highlighter-rouge">block</code> message. The first <code class="highlighter-rouge">block</code> message sent
(for block 1) is illustrated below.</p>

  <p><img src="/img/dev/en-ibd-block.svg" alt="First Block Message Sent During IBD" /></p>

  <p>The IBD node downloads each block, validates it, and then requests the
next block it hasn’t requested yet, maintaining a queue of up to 128
blocks to download. When it has requested every block for which it has
an inventory, it sends another <code class="highlighter-rouge">getblocks</code> message to the sync node
requesting the inventories of up to 500 more blocks.  This second
<code class="highlighter-rouge">getblocks</code> message contains multiple header hashes as illustrated
below:</p>

  <p><img src="/img/dev/en-ibd-getblocks2.svg" alt="Second GetBlocks Message Sent During IBD" /></p>

  <p>Upon receipt of the second <code class="highlighter-rouge">getblocks</code> message, the sync node searches
its local best block chain for a block that matches one of the header
hashes in the message, trying each hash in the order they were received.
If it finds a matching hash, it replies with 500 block inventories
starting with the next block from that point. But if there is no
matching hash (besides the stopping hash), it assumes the only block the
two nodes have in common is block 0 and so it sends an <code class="highlighter-rouge">inv</code> starting with
block 1 (the same <code class="highlighter-rouge">inv</code> message seen several illustrations above).</p>

  <p>This repeated search allows the sync node to send useful inventories even if
the IBD node’s local block chain forked from the sync node’s local block
chain. This fork detection becomes increasingly useful the closer the
IBD node gets to the tip of the block chain.</p>

  <p>When the IBD node receives the second <code class="highlighter-rouge">inv</code> message, it will request
those blocks using <code class="highlighter-rouge">getdata</code> messages.  The sync node will respond with
<code class="highlighter-rouge">block</code> messages.  Then the IBD node will request more inventories with
another <code class="highlighter-rouge">getblocks</code> message—and the cycle will repeat until the IBD
node is synced to the tip of the block chain.  At that point, the node
will accept blocks sent through the regular block broadcasting described
in a later subsection.</p>

  <h5 class="no_toc" id="blocks-first-advantages--disadvantages">Blocks-First Advantages &amp; Disadvantages</h5>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The primary advantage of blocks-first IBD is its simplicity. The primary
disadvantage is that the IBD node relies on a single sync node for all
of its downloading. This has several implications:</p>

  <ul>
    <li>
      <p><strong>Speed Limits:</strong> All requests are made to the sync node, so if the
sync node has limited upload bandwidth, the IBD node will have slow
download speeds.  Note: if the sync node goes offline, Bitcoin Core
will continue downloading from another node—but it will still only
download from a single sync node at a time.</p>
    </li>
    <li>
      <p><strong>Download Restarts:</strong> The sync node can send a non-best (but
otherwise valid) block chain to the IBD node. The IBD node won’t be
able to identify it as non-best until the initial block download nears
completion, forcing the IBD node to restart its block chain download
over again from a different node. Bitcoin Core ships with several
block chain checkpoints at various block heights selected by
developers to help an IBD node detect that it is being fed an
alternative block chain history—allowing the IBD node to restart
its download earlier in the process.</p>
    </li>
    <li>
      <p><strong>Disk Fill Attacks:</strong> Closely related to the download restarts, if
the sync node sends a non-best (but otherwise valid) block chain, the
chain will be stored on disk, wasting space and possibly filling up
the disk drive with useless data.</p>
    </li>
    <li>
      <p><strong>High Memory Use:</strong> Whether maliciously or by accident, the sync node
can send blocks out of order, creating orphan blocks which can’t be
validated until their parents have been received and validated.
Orphan blocks are stored in memory while they await validation,
which may lead to high memory use.</p>
    </li>
  </ul>

  <p>All of these problems are addressed in part or in full by the
headers-first IBD method used in Bitcoin Core 0.10.0.</p>

  <p><strong>Resources:</strong> The table below summarizes the messages mentioned
throughout this subsection. The links in the message field will take you
to the reference page for that message.</p>

  <table>
    <tbody>
      <tr>
        <td><strong>Message</strong></td>
        <td><a href="/en/developer-reference#getblocks" title="A P2P protocol message used to request an inv message containing a range of block header hashes"><code class="highlighter-rouge">getblocks</code></a></td>
        <td><a href="/en/developer-reference#inv" title="A P2P protocol message used to send inventories of transactions and blocks known to the transmitting peer"><code class="highlighter-rouge">inv</code></a></td>
        <td><a href="/en/developer-reference#getdata" title="A P2P protocol message used to request one or more transactions, blocks, or merkle blocks"><code class="highlighter-rouge">getdata</code></a></td>
        <td><a href="/en/developer-reference#block" title="The P2P network message which sends a serialized block"><code class="highlighter-rouge">block</code></a></td>
      </tr>
      <tr>
        <td><strong>From→To</strong></td>
        <td>IBD→Sync</td>
        <td>Sync→IBD</td>
        <td>IBD→Sync</td>
        <td>Sync→IBD</td>
      </tr>
      <tr>
        <td><strong>Payload</strong></td>
        <td>One or more header hashes</td>
        <td>Up to 500 block inventories (unique identifiers)</td>
        <td>One or more block inventories</td>
        <td>One serialized block</td>
      </tr>
    </tbody>
  </table>

  <h4 id="headers-first">Headers-First</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Bitcoin Core 0.10.0 uses an initial block download (IBD) method called
<em>headers-first</em>. The goal is to download the headers for the best <a href="/en/glossary/header-chain" title="A chain of block headers with each header linking to the header that preceded it; the most-difficult-to-recreate chain is the best header chain" id="term-header-chain" class="term">header
chain</a>, partially validate them as best
as possible, and then download the corresponding blocks in parallel.  This
solves several problems with the older blocks-first IBD method.</p>

  <p><img src="/img/dev/en-headers-first-flowchart.svg" alt="Overview Of Headers-First Method" /></p>

  <p>The first time a node is started, it only has a single block in its
local best block chain—the hardcoded genesis block (block 0).  The
node chooses a remote peer, which we’ll call the sync node, and sends it the
<code class="highlighter-rouge">getheaders</code> message illustrated below.</p>

  <p><img src="/img/dev/en-ibd-getheaders.svg" alt="First getheaders message" /></p>

  <p>In the header hashes field of the <code class="highlighter-rouge">getheaders</code> message, the new node
sends the header hash of the only block it has, the genesis block
(6fe2…0000 in internal byte order).  It also sets the stop hash field
to all zeroes to request a maximum-size response.</p>

  <p>Upon receipt of the <code class="highlighter-rouge">getheaders</code> message, the sync node takes the first
(and only) header hash and searches its local best block chain for a
block with that header hash. It finds that block 0 matches, so it
replies with 2,000 header (the maximum response) starting from
block 1. It sends these header hashes in the <code class="highlighter-rouge">headers</code> message
illustrated below.</p>

  <p><img src="/img/dev/en-ibd-headers.svg" alt="First headers message" /></p>

  <p>The IBD node can partially validate these block headers by ensuring that
all fields follow consensus rules and that the hash of the header is
below the target threshold according to the nBits field.  (Full
validation still requires all transactions from the corresponding
block.)</p>

  <p>After the IBD node has partially validated the block headers, it can do
two things in parallel:</p>

  <ol>
    <li>
      <p><strong>Download More Headers:</strong> the IBD node can send another <code class="highlighter-rouge">getheaders</code>
message to the sync node to request the next 2,000 headers on the
best header chain. Those headers can be immediately validated and
another batch requested repeatedly until a <code class="highlighter-rouge">headers</code> message is
received from the sync node with fewer than 2,000 headers, indicating
that it has no more headers to offer. As of this writing, headers
sync can be completed in fewer than 200 round trips, or about 32 MB
of downloaded data.</p>

      <p>Once the IBD node receives a <code class="highlighter-rouge">headers</code> message with fewer than 2,000
 headers from the sync node, it sends a <code class="highlighter-rouge">getheaders</code> message to each
 of its outbound peers to get their view of best header chain. By
 comparing the responses, it can easily determine if the headers it
 has downloaded belong to the best header chain reported by any of
 its outbound peers. This means a dishonest sync node will quickly be
 discovered even if checkpoints aren’t used (as long as the IBD node
 connects to at least one honest peer; Bitcoin Core will continue to
 provide checkpoints in case honest peers can’t be found).</p>
    </li>
    <li>
      <p><strong>Download Blocks:</strong> While the IBD node continues downloading
headers, and after the headers finish downloading, the IBD node will
request and download each block. The IBD node can use the block
header hashes it computed from the header chain to create <code class="highlighter-rouge">getdata</code>
messages that request the blocks it needs by their inventory. It
doesn’t need to request these from the sync node—it can request
them from any of its full node peers. (Although not all full nodes
may store all blocks.) This allows it to fetch blocks in parallel and
avoid having its download speed constrained to the upload speed of a
single sync node.</p>

      <p>To spread the load between multiple peers, Bitcoin Core will only
 request up to 16 blocks at a time from a single peer. Combined with
 its maximum of 8 outbound connections, this means headers-first
 Bitcoin Core will request a maximum of 128 blocks simultaneously
 during IBD (the same maximum number that blocks-first Bitcoin Core
 requested from its sync node).</p>
    </li>
  </ol>

  <p><img src="/img/dev/en-headers-first-moving-window.svg" alt="Simulated Headers-First Download Window" /></p>

  <p>Bitcoin Core’s headers-first mode uses a 1,024-block moving download
window to maximize download speed. The lowest-height block in the window
is the next block to be validated; if the block hasn’t arrived by the
time Bitcoin Core is ready to validate it, Bitcoin Core will wait a
minimum of two more seconds for the stalling node to send the block. If
the block still hasn’t arrived, Bitcoin Core will disconnect from the
stalling node and attempt to connect to another node. For example, in
the illustration above, Node A will be disconnected if it doesn’t send
block 3 within at least two seconds.</p>

  <p>Once the IBD node is synced to the tip of the block chain, it will
accept blocks sent through the regular block broadcasting described in a
later subsection.</p>

  <p><strong>Resources:</strong> The table below summarizes the messages mentioned
throughout this subsection. The links in the message field will take you
to the reference page for that message.</p>

  <table>
    <tbody>
      <tr>
        <td><strong>Message</strong></td>
        <td><a href="/en/developer-reference#getheaders" title="A P2P protocol message used to request a range of block headers"><code class="highlighter-rouge">getheaders</code></a></td>
        <td><a href="/en/developer-reference#headers" title="A P2P protocol message containing one or more block headers"><code class="highlighter-rouge">headers</code></a></td>
        <td><a href="/en/developer-reference#getdata" title="A P2P protocol message used to request one or more transactions, blocks, or merkle blocks"><code class="highlighter-rouge">getdata</code></a></td>
        <td><a href="/en/developer-reference#block" title="The P2P network message which sends a serialized block"><code class="highlighter-rouge">block</code></a></td>
      </tr>
      <tr>
        <td><strong>From→To</strong></td>
        <td>IBD→Sync</td>
        <td>Sync→IBD</td>
        <td>IBD→<em>Many</em></td>
        <td><em>Many</em>→IBD</td>
      </tr>
      <tr>
        <td><strong>Payload</strong></td>
        <td>One or more header hashes</td>
        <td>Up to 2,000 block headers</td>
        <td>One or more block inventories derived from header hashes</td>
        <td>One serialized block</td>
      </tr>
    </tbody>
  </table>

  <h3 id="block-broadcasting">Block Broadcasting</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>When a miner discovers a new block, it broadcasts the new block to its
peers using one of the following methods:</p>

  <ul>
    <li>
      <p><strong><a href="/en/developer-guide#term-unsolicited-block-push" title="When a miner sends a block message without sending an inv message first" id="term-unsolicited-block-push" class="term">Unsolicited Block Push</a>:</strong>
the miner sends a <code class="highlighter-rouge">block</code> message to each of its full node peers with
the new block. The miner can reasonably bypass the standard relay
method in this way because it knows none of its peers already have the
just-discovered block.</p>
    </li>
    <li>
      <p><strong><a href="/en/developer-guide#term-standard-block-relay" title="The regular block relay method: announcing a block with an inv message and waiting for a response" id="term-standard-block-relay" class="term">Standard Block Relay</a>:</strong>
the miner, acting as a standard relay node, sends an <code class="highlighter-rouge">inv</code> message to
each of its peers (both full node and SPV) with an inventory referring
to the new block. The most common responses are:</p>

      <ul>
        <li>
          <p>Each blocks-first (BF) peer that wants the block replies with a
<code class="highlighter-rouge">getdata</code> message requesting the full block.</p>
        </li>
        <li>
          <p>Each headers-first (HF) peer that wants the block replies with a
<code class="highlighter-rouge">getheaders</code> message containing the header hash of the
highest-height header on its best header chain, and likely also
some headers further back on the best header chain to allow fork
detection. That message is immediately followed by a <code class="highlighter-rouge">getdata</code>
message requesting the full block. By requesting headers first, a
headers-first peer can refuse orphan blocks as described in the
subsection below.</p>
        </li>
        <li>
          <p>Each Simplified Payment Verification (SPV) client that wants the
block replies with a <code class="highlighter-rouge">getdata</code> message typically requesting a
merkle block.</p>
        </li>
      </ul>

      <p>The miner replies to each request accordingly by sending the block
 in a <code class="highlighter-rouge">block</code> message, one or more headers in a <code class="highlighter-rouge">headers</code> message,
 or the merkle block and transactions relative to the SPV client’s
 bloom filter in a <code class="highlighter-rouge">merkleblock</code> message followed by zero or more
 <code class="highlighter-rouge">tx</code> messages.</p>
    </li>
  </ul>

  <p>By default, Bitcoin Core broadcasts blocks using standard block relay,
but it will accept blocks sent using either of the methods described above.</p>

  <p>Full nodes validate the received block and then advertise it to their
peers using the standard block relay method described above.  The condensed
table below highlights the operation of the messages described above
(Relay, BF, HF, and SPV refer to the relay node, a blocks-first node, a
headers-first node, and an SPV client; <em>any</em> refers to a node using any
block retrieval method.)</p>

  <table>
    <tbody>
      <tr>
        <td><strong>Message</strong></td>
        <td><a href="/en/developer-reference#inv" title="A P2P protocol message used to send inventories of transactions and blocks known to the transmitting peer"><code class="highlighter-rouge">inv</code></a></td>
        <td><a href="/en/developer-reference#getdata" title="A P2P protocol message used to request one or more transactions, blocks, or merkle blocks"><code class="highlighter-rouge">getdata</code></a></td>
        <td><a href="/en/developer-reference#getheaders" title="A P2P protocol message used to request a range of block headers"><code class="highlighter-rouge">getheaders</code></a></td>
        <td><a href="/en/developer-reference#headers" title="A P2P protocol message containing one or more block headers"><code class="highlighter-rouge">headers</code></a></td>
      </tr>
      <tr>
        <td><strong>From→To</strong></td>
        <td>Relay→<em>Any</em></td>
        <td>BF→Relay</td>
        <td>HF→Relay</td>
        <td>Relay→HF</td>
      </tr>
      <tr>
        <td><strong>Payload</strong></td>
        <td>The inventory of the new block</td>
        <td>The inventory of the new block</td>
        <td>One or more header hashes on the HF node’s best header chain (BHC)</td>
        <td>Up to 2,000 headers connecting HF node’s BHC to relay node’s BHC</td>
      </tr>
      <tr>
        <td><strong>Message</strong></td>
        <td><a href="/en/developer-reference#block" title="The P2P network message which sends a serialized block"><code class="highlighter-rouge">block</code></a></td>
        <td><a href="/en/developer-reference#merkleblock" title="A P2P protocol message used to request a filtered block useful for SPV proofs"><code class="highlighter-rouge">merkleblock</code></a></td>
        <td><a href="/en/developer-reference#tx" title="A P2P protocol message which sends a single serialized transaction"><code class="highlighter-rouge">tx</code></a></td>
        <td> </td>
      </tr>
      <tr>
        <td><strong>From→To</strong></td>
        <td>Relay→BF/HF</td>
        <td>Relay→SPV</td>
        <td>Relay→SPV</td>
        <td> </td>
      </tr>
      <tr>
        <td><strong>Payload</strong></td>
        <td>The new block in <a href="/en/developer-reference#serialized-blocks">serialized format</a></td>
        <td>The new block filtered into a merkle block</td>
        <td>Serialized transactions from the new block that match the bloom filter</td>
        <td> </td>
      </tr>
    </tbody>
  </table>

  <h4 id="orphan-blocks">Orphan Blocks</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Blocks-first nodes may download orphan blocks—blocks whose previous
block header hash field refers to a block header this node
hasn’t seen yet. In other words, orphan blocks have no known parent
(unlike stale blocks, which have known parents but which aren’t part of
the best block chain).</p>

  <p><img src="/img/dev/en-orphan-stale-definition.svg" alt="Difference Between Orphan And Stale Blocks" /></p>

  <p>When a blocks-first node downloads an orphan block, it will not validate
it. Instead, it will send a <code class="highlighter-rouge">getblocks</code> message to the node which sent
the orphan block; the broadcasting node will respond with an <code class="highlighter-rouge">inv</code> message
containing inventories of any blocks the downloading node is missing (up
to 500); the downloading node will request those blocks with a <code class="highlighter-rouge">getdata</code>
message; and the broadcasting node will send those blocks with a <code class="highlighter-rouge">block</code>
message. The downloading node will validate those blocks, and once the
parent of the former orphan block has been validated, it will validate
the former orphan block.</p>

  <p>Headers-first nodes avoid some of this complexity by always requesting
block headers with the <code class="highlighter-rouge">getheaders</code> message before requesting a block
with the <code class="highlighter-rouge">getdata</code> message. The broadcasting node will send a <code class="highlighter-rouge">headers</code>
message containing all the block headers (up to 2,000) it thinks the
downloading node needs to reach the tip of the best header chain; each of
those headers will point to its parent, so when the downloading node
receives the <code class="highlighter-rouge">block</code> message, the block shouldn’t be an orphan
block—all of its parents should be known (even if they haven’t been
validated yet). If, despite this, the block received in the <code class="highlighter-rouge">block</code>
message is an orphan block, a headers-first node will discard it immediately.</p>

  <p>However, orphan discarding does mean that headers-first nodes will
ignore orphan blocks sent by miners in an unsolicited block push.</p>

  <h3 id="transaction-broadcasting">Transaction Broadcasting</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>In order to send a transaction to a peer, an <code class="highlighter-rouge">inv</code> message is sent. If a <code class="highlighter-rouge">getdata</code> response message is received, the transaction is sent using <code class="highlighter-rouge">tx</code>. The peer receiving this transaction also forwards the transaction in the same manner, given that it is a valid transaction.</p>

  <h4 id="memory-pool">Memory Pool</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Full peers may keep track of unconfirmed transactions which are eligible to
be included in the next block. This is essential for miners who will
actually mine some or all of those transactions, but it’s also useful
for any peer who wants to keep track of unconfirmed transactions, such
as peers serving unconfirmed transaction information to SPV clients.</p>

  <p>Because unconfirmed transactions have no permanent status in Bitcoin,
Bitcoin Core stores them in non-persistent memory, calling them a memory
pool or mempool. When a peer shuts down, its memory pool is lost except
for any transactions stored by its wallet. This means that never-mined
unconfirmed transactions tend to slowly disappear from the network as
peers restart or as they purge some transactions to make room in memory
for others.</p>

  <p>Transactions which are mined into blocks that later become stale blocks may be
added back into the memory pool. These re-added transactions may be
re-removed from the pool almost immediately if the replacement blocks
include them. This is the case in Bitcoin Core, which removes stale
blocks from the chain one by one, starting with the tip (highest block).
As each block is removed, its transactions are added back to the memory
pool. After all of the stale blocks are removed, the replacement
blocks are added to the chain one by one, ending with the new tip. As
each block is added, any transactions it confirms are removed from the
memory pool.</p>

  <p>SPV clients don’t have a memory pool for the same reason they don’t
relay transactions. They can’t independently verify that a transaction
hasn’t yet been included in a block and that it only spends UTXOs, so
they can’t know which transactions are eligible to be included in the
next block.</p>

  <h3 id="misbehaving-nodes">Misbehaving Nodes</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Take note that for both types of broadcasting, mechanisms are in place to punish misbehaving peers who take up bandwidth and computing resources by sending false information. If a peer gets a banscore above the <code class="highlighter-rouge">-banscore=&lt;n&gt;</code> threshold, he will be banned for the number of seconds defined by <code class="highlighter-rouge">-bantime=&lt;n&gt;</code>, which is 86,400 by default (24 hours).</p>

  <h3 id="alerts">Alerts</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_p2p_network.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_p2p_network.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_p2p_network.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_p2p_network.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p><em>Removed in Bitcoin Core 0.13.0</em></p>

  <p>Earlier versions of Bitcoin Core allowed developers and trusted community members to issue <a href="https://bitcoin.org/en/alerts">Bitcoin alerts</a> to notify users of critical network-wide issues. This messaging system <a href="https://bitcoin.org/en/alert/2016-11-01-alert-retirement">was retired</a> in Bitcoin Core v0.13.0; however, internal alerts, partition detection warnings and the <code class="highlighter-rouge">-alertnotify</code> option features remain.</p>

  <h2 id="mining">Mining</h2>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_mining.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_mining.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_mining.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_mining.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Mining adds new blocks to the block chain, making transaction history
hard to modify.  Mining today takes on two forms:</p>

  <ul>
    <li>
      <p>Solo mining, where the miner attempts to generate new blocks on his
own, with the proceeds from the block reward and transaction fees
going entirely to himself, allowing him to receive large payments with
a higher variance (longer time between payments)</p>
    </li>
    <li>
      <p>Pooled mining, where the miner pools resources with other miners to
find blocks more often, with the proceeds being shared among the pool
miners in rough correlation to the amount of hashing power
they each contributed, allowing the miner to receive small
payments with a lower variance (shorter time between payments).</p>
    </li>
  </ul>

  <h3 id="solo-mining">Solo Mining</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_mining.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_mining.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_mining.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_mining.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>As illustrated below, solo miners typically use <code class="highlighter-rouge">bitcoind</code> to get new
transactions from the network. Their mining software periodically polls
<code class="highlighter-rouge">bitcoind</code> for new transactions using the <code class="highlighter-rouge">getblocktemplate</code> RPC, which
provides the list of new transactions plus the public key to which the
coinbase transaction should be sent.</p>

  <p><img src="/img/dev/en-solo-mining-overview.svg" alt="Solo Bitcoin Mining" /></p>

  <p>The mining software constructs a block using the template (described below) and creates a
block header. It then sends the 80-byte block header to its mining
hardware (an ASIC) along with a target threshold (difficulty setting).
The mining hardware iterates through every possible value for the block
header nonce and generates the corresponding hash.</p>

  <p>If none of the hashes are below the threshold, the mining hardware gets
an updated block header with a new merkle root from the mining software;
this new block header is created by adding extra nonce data to the
coinbase field of the coinbase transaction.</p>

  <p>On the other hand, if a hash is found below the target threshold, the
mining hardware returns the block header with the successful nonce to
the mining software. The mining software combines the header with the
block and sends the completed block to <code class="highlighter-rouge">bitcoind</code> to be broadcast to the network for addition to the
block chain.</p>

  <h3 id="pool-mining">Pool Mining</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_mining.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_mining.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_mining.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_mining.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>Pool miners follow a similar workflow, illustrated below, which allows
mining pool operators to pay miners based on their share of the work
done. The mining pool gets new transactions from the network using
<code class="highlighter-rouge">bitcoind</code>. Using one of the methods discussed later, each miner’s mining
software connects to the pool and requests the information it needs to
construct block headers.</p>

  <p><img src="/img/dev/en-pooled-mining-overview.svg" alt="Pooled Bitcoin Mining" /></p>

  <p>In pooled mining, the mining pool sets the target threshold a few orders
of magnitude higher (less difficult) than the network
difficulty. This causes the mining hardware to return many block headers
which don’t hash to a value eligible for inclusion on the block chain
but which do hash below the pool’s target, proving (on average) that the
miner checked a percentage of the possible hash values.</p>

  <p>The miner then sends to the pool a copy of the information the pool
needs to validate that the header will hash below the target and that
the the block of transactions referred to by the header merkle root field
is valid for the pool’s purposes. (This usually means that the coinbase
transaction must pay the pool.)</p>

  <p>The information the miner sends to the pool is called a share because it
proves the miner did a share of the work. By chance, some shares the
pool receives will also be below the network target—the mining pool
sends these to the network to be added to the block chain.</p>

  <p>The block reward and transaction fees that come from mining that block
are paid to the mining pool. The mining pool pays out a portion of
these proceeds to individual miners based on how many shares they generated. For
example, if the mining pool’s target threshold is 100 times lower than
the network target threshold, 100 shares will need to be generated on
average to create a successful block, so the mining pool can pay 1/100th
of its payout for each share received.  Different mining pools use
different reward distribution systems based on this basic share system.</p>

  <h3 id="block-prototypes">Block Prototypes</h3>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_mining.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_mining.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_mining.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_mining.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>In both solo and pool mining, the mining software needs to get the
information necessary to construct block headers. This subsection
describes, in a linear way, how that information is transmitted and
used. However, in actual implementations, parallel threads and queuing
are used to keep ASIC hashers working at maximum capacity,</p>

  <h4 id="getwork-rpc">getwork RPC</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_mining.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_mining.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_mining.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_mining.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>The simplest and earliest method was the now-deprecated Bitcoin Core
<code class="highlighter-rouge">getwork</code> RPC, which constructs a header for the miner directly. Since a
header only contains a single 4-byte nonce good for about 4 gigahashes,
many modern miners need to make dozens or hundreds of <code class="highlighter-rouge">getwork</code> requests
a second. Solo miners may still use <code class="highlighter-rouge">getwork</code> on v0.9.5 or below, but most pools today
discourage or disallow its use.</p>

  <h4 id="getblocktemplate-rpc">getblocktemplate RPC</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_mining.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_mining.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_mining.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_mining.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>An improved method is the Bitcoin Core <code class="highlighter-rouge">getblocktemplate</code> RPC. This
provides the mining software with much more information:</p>

  <ol>
    <li>
      <p>The information necessary to construct a coinbase transaction
paying the pool or the solo miner’s <code class="highlighter-rouge">bitcoind</code> wallet.</p>
    </li>
    <li>
      <p>A complete dump of the transactions <code class="highlighter-rouge">bitcoind</code> or the mining pool
suggests including in the block, allowing the mining software to
inspect the transactions, optionally add additional transactions, and
optionally remove non-required transactions.</p>
    </li>
    <li>
      <p>Other information necessary to construct a block header for the next
block: the block version, previous block hash, and bits (target).</p>
    </li>
    <li>
      <p>The mining pool’s current target threshold for accepting shares. (For
solo miners, this is the network target.)</p>
    </li>
  </ol>

  <p>Using the transactions received, the mining software adds a nonce to the
coinbase extra nonce field and then converts all the transactions into a
merkle tree to derive a merkle root it can use in a block header.
Whenever the extra nonce field needs to be changed, the mining software
rebuilds the necessary parts of the merkle tree and updates the time and
merkle root fields in the block header.</p>

  <p>Like all <code class="highlighter-rouge">bitcoind</code> RPCs, <code class="highlighter-rouge">getblocktemplate</code> is sent over HTTP. To
ensure they get the most recent work, most miners use <a href="https://en.wikipedia.org/wiki/Push_technology#Long_polling">HTTP longpoll</a> to
leave a <code class="highlighter-rouge">getblocktemplate</code> request open at all times. This allows the
mining pool to push a new <code class="highlighter-rouge">getblocktemplate</code> to the miner as soon as any
miner on the peer-to-peer network publishes a new block or the pool
wants to send more transactions to the mining software.</p>

  <h4 id="stratum">Stratum</h4>
  <div class="subhead-links sourcefile" data-sourcefile="_includes/devdoc/guide_mining.md"><a href="https://github.com/thephez/dash.org/edit/master/_includes/devdoc/guide_mining.md">Edit</a>
| <a href="https://github.com/thephez/dash.org/commits/master/_includes/devdoc/guide_mining.md">History</a>
| <a href="https://github.com/thephez/dash.org/issues/new?body=Source%20File%3A%20_includes/devdoc/guide_mining.md%0A%0A">Report Issue</a>
| <a href="/en/development#devcommunities">Discuss</a></div>

  <p>A widely used alternative to <code class="highlighter-rouge">getblocktemplate</code> is the <a href="http://mining.bitcoin.cz/stratum-mining">Stratum mining
protocol</a>. Stratum focuses on giving miners the minimal information they
need to construct block headers on their own:</p>

  <ol>
    <li>
      <p>The information necessary to construct a coinbase transaction
paying the pool.</p>
    </li>
    <li>
      <p>The parts of the merkle tree which need to be re-hashed to
create a new merkle root when the coinbase transaction is
updated with a new extra nonce. The other parts of the merkle
tree, if any, are not sent, effectively limiting the amount of data which needs
to be sent to (at most) about a kilobyte at current transaction
volume.</p>
    </li>
    <li>
      <p>All of the other non-merkle root information necessary to construct a
block header for the next block.</p>
    </li>
    <li>
      <p>The mining pool’s current target threshold for accepting shares.</p>
    </li>
  </ol>

  <p>Using the coinbase transaction received, the mining software adds a
nonce to the coinbase extra nonce field, hashes the coinbase
transaction, and adds the hash to the received parts of the merkle tree.
The tree is hashed as necessary to create a merkle root, which is added
to the block header information received. Whenever the extra nonce field
needs to be changed, the mining software updates and re-hashes the
coinbase transaction, rebuilds the merkle root, and updates the header
merkle root field.</p>

  <p>Unlike <code class="highlighter-rouge">getblocktemplate</code>, miners using Stratum cannot inspect or add
transactions to the block they’re currently mining. Also unlike
<code class="highlighter-rouge">getblocktemplate</code>, the Stratum protocol uses a two-way TCP socket directly,
so miners don’t need to use HTTP longpoll to ensure they receive
immediate updates from mining pools when a new block is broadcast to the
peer-to-peer network.</p>

  <!-- SOMEDAY: describe p2pool -->

  <p><strong>Resources:</strong> The GPLv3 <a href="https://github.com/luke-jr/bfgminer">BFGMiner</a> mining software and AGPLv3
<a href="https://github.com/luke-jr/eloipool">Eloipool</a> mining pool software are widely-used among miners and
pools. The <a href="https://github.com/bitcoin/libblkmaker">libblkmaker</a> C library and <a href="https://gitorious.org/bitcoin/python-blkmaker">python-blkmaker</a> library,
both MIT licensed, can interpret GetBlockTemplate for your programs.</p>

  <!-- Inventory Messages -->
  <!-- Inventory Messages: Dash Specific -->

  <!--[bitcoin-documentation mailing list]: https://groups.google.com/forum/#!forum/bitcoin-documentation-->

</div>

</div>

  <div class="footer">
    



    

<div class="footersponsor">
  <!--<div><span>A community website sponsored by</span> <a href="https://bitcoinfoundation.org/"><img src="/img/brand/bitcoinfoundation.png" alt="Bitcoin Foundation"></a></div>-->
</div>

    

<div class="footerlicense">© Bitcoin Project 2009-2017 Released under the <a href="http://opensource.org/licenses/mit-license.php" target="_blank">MIT license</a></div>

  </div>
</div>



<script type="text/javascript">
  fallbackSVG();
  addAnchorLinks();
  trackOutgoingLinks();
</script>



  <script src="/js/jquery/jquery-1.11.2.min.js"></script>
<script src="/js/jquery/jquery-ui.min.js"></script>
<script src="/js/devsearch.js"></script>
<script>updateToc();</script>



</body>

</html>
